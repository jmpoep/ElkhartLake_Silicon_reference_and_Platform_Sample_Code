/** @file

@copyright
  INTEL CONFIDENTIAL
  Copyright 2014 - 2020 Intel Corporation.

  The source code contained or described herein and all documents related to the
  source code ("Material") are owned by Intel Corporation or its suppliers or
  licensors. Title to the Material remains with Intel Corporation or its suppliers
  and licensors. The Material may contain trade secrets and proprietary and
  confidential information of Intel Corporation and its suppliers and licensors,
  and is protected by worldwide copyright and trade secret laws and treaty
  provisions. No part of the Material may be used, copied, reproduced, modified,
  published, uploaded, posted, transmitted, distributed, or disclosed in any way
  without Intel's prior express written permission.

  No license under any patent, copyright, trade secret or other intellectual
  property right is granted to or conferred upon you by disclosure or delivery
  of the Materials, either expressly, by implication, inducement, estoppel or
  otherwise. Any license under such intellectual property rights must be
  express and approved by Intel in writing.

  Unless otherwise agreed by Intel in writing, you may not remove or alter
  this notice or any other notice embedded in Materials by Intel or
  Intel's suppliers or licensors in any way.

  This file contains a 'Sample Driver' and is licensed as such under the terms
  of your license agreement with Intel or your vendor. This file may be modified
  by the user, subject to the additional terms of the license agreement.

@par Specification
**/

#include "SetupPreProcTools.hfr"

    form formid = AUTO_ID(MEMORY_FORM_ID),
    title = STRING_TOKEN(STR_MEMORY_FORM);

      goto MEMORY_THERMAL_CONFIG_FORM_ID,
        prompt = STRING_TOKEN(STR_MEMORY_THERMAL_CONFIG_FORM_TITLE),
        help = STRING_TOKEN(STR_MEMORY_THERMAL_CONFIG_FORM_HELP);

      goto MEM_TRAINING_FORM_ID,
        prompt  = STRING_TOKEN(STR_MEMORY_TRAINING_ALGOS_PROMPT),
        help    = STRING_TOKEN(STR_MEMORY_TRAINING_ALGOS_HELP);


      SUBTITLE(STRING_TOKEN(STR_MEMORY_FORM))
      SEPARATOR

      text
        help   = STRING_TOKEN(STR_MRC_REV_HELP),
        text   = STRING_TOKEN(STR_MRC_REV_NAME),
        text   = STRING_TOKEN(STR_MRC_REV_VALUE),
        flags  = 0,
        key    = 0;

      text
        help   = STRING_TOKEN(STR_MEMORY_FREQ_HELP),
        text   = STRING_TOKEN(STR_MEMORY_FREQ_NAME),
        text   = STRING_TOKEN(STR_MEMORY_FREQ_VALUE),
        flags  = 0,
        key    = 0;

      text
        help   = STRING_TOKEN(STR_MEMORY_TIMINGS_HELP),
        text   = STRING_TOKEN(STR_MEMORY_TIMINGS_NAME),
        text   = STRING_TOKEN(STR_MEMORY_TIMINGS_VALUE),
        flags  = 0,
        key    = 0;

      SEPARATOR
      text
        help   = STRING_TOKEN(STR_DIMM_CH_SLT_SUBTITLE_HELP),
        text   = STRING_TOKEN(STR_DIMM_CH0_SLT0_FORM_SUBTITLE),
        text   = STRING_TOKEN(STR_DIMM_CH0_SLT0_STATUS),
        flags  = 0,
        key    = 0;

      suppressif ideqval SETUP_VOLATILE_DATA.DimmPresent[OFFSET_0] == 0x0;
        text
          help   = STRING_TOKEN(STR_DIMM_SIZE_HELP),
          text   = STRING_TOKEN(STR_DIMM_SIZE_NAME),
          text   = STRING_TOKEN(STR_DIMM_SIZE_CH0_SLT0_VALUE),
          flags  = 0,
          key    = 0;
        text
          help   = STRING_TOKEN(STR_DIMM_NUM_RANKS_HELP),
          text   = STRING_TOKEN(STR_DIMM_NUM_RANKS_NAME),
          text   = STRING_TOKEN(STR_DIMM_CH0_SLT0_RANK_VALUE),
          flags  = 0,
          key    = 0;
        text
          help   = STRING_TOKEN(STR_DIMM_MFG_HELP),
          text   = STRING_TOKEN(STR_DIMM_MFG_NAME),
          text   = STRING_TOKEN(STR_DIMM_CH0_SLT0_MFG_VALUE),
          flags  = 0,
          key    = 0;
      endif;

      text
          help   = STRING_TOKEN(STR_DIMM_CH_SLT_SUBTITLE_HELP),
          text   = STRING_TOKEN(STR_DIMM_CH0_SLT1_FORM_SUBTITLE),
          text   = STRING_TOKEN(STR_DIMM_CH0_SLT1_STATUS),
          flags  = 0,
          key    = 0;

      suppressif ideqval SETUP_VOLATILE_DATA.DimmPresent[OFFSET_1] == 0x0;
        text
          help   = STRING_TOKEN(STR_DIMM_SIZE_HELP),
          text   = STRING_TOKEN(STR_DIMM_SIZE_NAME),
          text   = STRING_TOKEN(STR_DIMM_SIZE_CH0_SLT1_VALUE),
          flags  = 0,
          key    = 0;
        text
          help   = STRING_TOKEN(STR_DIMM_NUM_RANKS_HELP),
          text   = STRING_TOKEN(STR_DIMM_NUM_RANKS_NAME),
          text   = STRING_TOKEN(STR_DIMM_CH0_SLT1_RANK_VALUE),
          flags  = 0,
          key    = 0;
        text
          help   = STRING_TOKEN(STR_DIMM_MFG_HELP),
          text   = STRING_TOKEN(STR_DIMM_MFG_NAME),
          text   = STRING_TOKEN(STR_DIMM_CH0_SLT1_MFG_VALUE),
          flags  = 0,
          key    = 0;
      endif;

      text
        help   = STRING_TOKEN(STR_DIMM_CH_SLT_SUBTITLE_HELP),
        text   = STRING_TOKEN(STR_DIMM_CH1_SLT0_FORM_SUBTITLE),
        text   = STRING_TOKEN(STR_DIMM_CH1_SLT0_STATUS),
        flags  = 0,
        key    = 0;

      suppressif ideqval SETUP_VOLATILE_DATA.DimmPresent[OFFSET_2] == 0x0;
        text
          help   = STRING_TOKEN(STR_DIMM_SIZE_HELP),
          text   = STRING_TOKEN(STR_DIMM_SIZE_NAME),
          text   = STRING_TOKEN(STR_DIMM_SIZE_CH1_SLT0_VALUE),
          flags  = 0,
          key    = 0;
        text
          help   = STRING_TOKEN(STR_DIMM_NUM_RANKS_HELP),
          text   = STRING_TOKEN(STR_DIMM_NUM_RANKS_NAME),
          text   = STRING_TOKEN(STR_DIMM_CH1_SLT0_RANK_VALUE),
          flags  = 0,
          key    = 0;
        text
          help   = STRING_TOKEN(STR_DIMM_MFG_HELP),
          text   = STRING_TOKEN(STR_DIMM_MFG_NAME),
          text   = STRING_TOKEN(STR_DIMM_CH1_SLT0_MFG_VALUE),
          flags  = 0,
          key    = 0;
      endif;

      text
          help   = STRING_TOKEN(STR_DIMM_CH_SLT_SUBTITLE_HELP),
          text   = STRING_TOKEN(STR_DIMM_CH1_SLT1_FORM_SUBTITLE),
          text   = STRING_TOKEN(STR_DIMM_CH1_SLT1_STATUS),
          flags  = 0,
          key    = 0;

      suppressif ideqval SETUP_VOLATILE_DATA.DimmPresent[OFFSET_3] == 0x0;
        text
          help   = STRING_TOKEN(STR_DIMM_SIZE_HELP),
          text   = STRING_TOKEN(STR_DIMM_SIZE_NAME),
          text   = STRING_TOKEN(STR_DIMM_SIZE_CH1_SLT1_VALUE),
          flags  = 0,
          key    = 0;
        text
          help   = STRING_TOKEN(STR_DIMM_NUM_RANKS_HELP),
          text   = STRING_TOKEN(STR_DIMM_NUM_RANKS_NAME),
          text   = STRING_TOKEN(STR_DIMM_CH1_SLT1_RANK_VALUE),
          flags  = 0,
          key    = 0;
        text
          help   = STRING_TOKEN(STR_DIMM_MFG_HELP),
          text   = STRING_TOKEN(STR_DIMM_MFG_NAME),
          text   = STRING_TOKEN(STR_DIMM_CH1_SLT1_MFG_VALUE),
          flags  = 0,
          key    = 0;
      endif;

      SEPARATOR

      text
        help   = STRING_TOKEN(STR_MRC_RATIO_MOVED_HELP),
        text   = STRING_TOKEN(STR_MRC_RATIO_MOVED),
        flags  = 0,
        key    = 0;

      oneof varid  = SA_SETUP.MrcSafeConfig,
        prompt      = STRING_TOKEN (STR_MRC_ULT_SAFE_CONFIG_PROMPT),
        help        = STRING_TOKEN (STR_MRC_ULT_SAFE_CONFIG_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid  = SA_SETUP.SafeMode,
        prompt   = STRING_TOKEN (STR_SAFE_MODE_SUPPORT_PROMPT),
        help     = STRING_TOKEN (STR_SAFE_MODE_SUPPORT_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;

      //
      // DDR Frequency Limit values must match the definitions in $(SI_PACKAGE)\SystemAgent\MemoryInit\Include\MrcInterface.h
      //
      oneof varid = SA_SETUP.DdrFreqLimit,
        prompt  = STRING_TOKEN(STR_DDR_FREQ_LIMIT_PROMPT),
        help    = STRING_TOKEN(STR_DDR_FREQ_LIMIT_PROMPT_HELP),
        default  = 0, defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_AUTO_STRING),           value = 0,    flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_1067_STRING), value = 1067, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_1200_STRING), value = 1200, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_1333_STRING), value = 1333, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_1400_STRING), value = 1400, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_1600_STRING), value = 1600, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_1800_STRING), value = 1800, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_1867_STRING), value = 1867, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_2000_STRING), value = 2000, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_2133_STRING), value = 2133, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_2200_STRING), value = 2200, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_2400_STRING), value = 2400, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_2600_STRING), value = 2600, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_2667_STRING), value = 2667, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_2800_STRING), value = 2800, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_2933_STRING), value = 2933, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_3000_STRING), value = 3000, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_3200_STRING), value = 3200, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_3467_STRING), value = 3467, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_3600_STRING), value = 3600, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_3733_STRING), value = 3733, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_4000_STRING), value = 4000, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_4200_STRING), value = 4200, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DDR3_FREQ_4267_STRING), value = 4267, flags = RESET_REQUIRED;
      endoneof;

      oneof varid    = SA_SETUP.HobBufferSize,
        prompt   = STRING_TOKEN(STR_HOB_BUFFER_SIZE_PROMPT),
        help     = STRING_TOKEN(STR_HOB_BUFFER_SIZE_HELP),
        option text = STRING_TOKEN(STR_AUTO_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_1B),          value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_1KB),         value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX),         value = 3, flags = RESET_REQUIRED;
      endoneof;

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorDesktop AND
                 NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorEmbedded AND
                 NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer AND
                 NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorWorkstation;
        oneof varid  = SA_SETUP.EccSupport,
          prompt   = STRING_TOKEN (STR_ECC_SUPPORT_PROMPT),
          help     = STRING_TOKEN (STR_ECC_SUPPORT_HELP),
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      //
      // Max TOLUD setup option
      //
      oneof varid    = SA_SETUP.MaxTolud,
        prompt   = STRING_TOKEN(STR_MAX_TOLUD_PROMPT),
        help     = STRING_TOKEN(STR_MAX_TOLUD_HELP),
        default  = MAX_TOLUD_DYNAMIC, defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_MAX_TOLUD_DYNAMIC_STRING), value = MAX_TOLUD_DYNAMIC, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_1G_STRING),      value = MAX_TOLUD_1G,      flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_1_25G_STRING),   value = MAX_TOLUD_1_25G,   flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_1_5G_STRING),    value = MAX_TOLUD_1_5G,    flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_1_75G_STRING),   value = MAX_TOLUD_1_75G,   flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_2G_STRING),      value = MAX_TOLUD_2G,      flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_2_25G_STRING),   value = MAX_TOLUD_2_25G,   flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_2_5G_STRING),    value = MAX_TOLUD_2_5G,    flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_2_75G_STRING),   value = MAX_TOLUD_2_75G,   flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_3G_STRING),      value = MAX_TOLUD_3G,      flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_3_25G_STRING),   value = MAX_TOLUD_3_25G,   flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MAX_TOLUD_3_5G_STRING),    value = MAX_TOLUD_3_5G,    flags = RESET_REQUIRED;
      endoneof;

      grayoutif ideqval SETUP_DATA.TccMode == 1;
        oneof varid  = SA_SETUP.SaGv,
          questionid = AUTO_ID(SA_GV_QUESTION_ID),
          prompt     = STRING_TOKEN (STR_SA_GV_PROMPT),
          help       = STRING_TOKEN (STR_SA_GV_HELP),
          option text = STRING_TOKEN (STR_DISABLED_STRING),   value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_FIXED_LOW_STRING),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_FIXED_MID_STRING),  value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_FIXED_HIGH_STRING), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_ENABLED_STRING),    value = 4, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid  = SA_SETUP.DdrSpeedControl,
        prompt     = STRING_TOKEN (STR_DDR_SPEED_CONTROL_PROMPT),
        help       = STRING_TOKEN (STR_DDR_SPEED_CONTROL_HELP),
        option text = STRING_TOKEN (STR_AUTO_STRING),   value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_MANUAL_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;

      // Hide if DDR Speed Control is Auto or if SAGV is not Enabled / FixedLow
      suppressif (NOT ideqval SA_SETUP.SaGv == 1 AND
                 NOT ideqval SA_SETUP.SaGv == 4) OR
                 NOT ideqval SA_SETUP.DdrSpeedControl == 1;
        oneof varid  = SA_SETUP.FreqSaGvLow,
          prompt   = STRING_TOKEN (STR_SA_GV_LOW_PROMPT),
          help     = STRING_TOKEN (STR_SA_GV_LOW_HELP),
          option text = STRING_TOKEN (STR_MRC_DEFAULT),           value =    0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1067_STRING), value = 1067, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1200_STRING), value = 1200, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1333_STRING), value = 1333, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1400_STRING), value = 1400, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1600_STRING), value = 1600, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1800_STRING), value = 1800, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1867_STRING), value = 1867, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2133_STRING), value = 2133, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2400_STRING), value = 2400, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2667_STRING), value = 2667, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2933_STRING), value = 2933, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_3200_STRING), value = 3200, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_3467_STRING), value = 3467, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_3733_STRING), value = 3733, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_4000_STRING), value = 4000, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_4267_STRING), value = 4267, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Hide if DDR Speed Control is Auto or if SAGV is not Enabled / FixedMid
      suppressif (NOT ideqval SA_SETUP.SaGv == 2 AND
                  NOT ideqval SA_SETUP.SaGv == 4) OR
                 NOT ideqval SA_SETUP.DdrSpeedControl == 1;
        oneof varid  = SA_SETUP.FreqSaGvMid,
          prompt   = STRING_TOKEN (STR_SA_GV_MID_PROMPT),
          help     = STRING_TOKEN (STR_SA_GV_MID_HELP),
          option text = STRING_TOKEN (STR_MRC_DEFAULT),           value =    0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1067_STRING), value = 1067, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1333_STRING), value = 1333, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1600_STRING), value = 1600, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1800_STRING), value = 1800, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_1867_STRING), value = 1867, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2000_STRING), value = 2000, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2133_STRING), value = 2133, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2400_STRING), value = 2400, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2667_STRING), value = 2667, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_2933_STRING), value = 2933, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_3200_STRING), value = 3200, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_3467_STRING), value = 3467, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_3733_STRING), value = 3733, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_4000_STRING), value = 4000, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DDR3_FREQ_4267_STRING), value = 4267, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Hide if DDR Speed Control is Auto or if SAGV is not Enabled / FixedLow
      suppressif (NOT ideqval SA_SETUP.SaGv == 1 AND
                  NOT ideqval SA_SETUP.SaGv == 4) OR
                 NOT ideqval SA_SETUP.DdrSpeedControl == 1;
        oneof varid  = SA_SETUP.SaGvLowGear2,
          prompt     = STRING_TOKEN (STR_SAGV_LOW_GEAR2_PROMPT),
          help       = STRING_TOKEN (STR_SAGV_LOW_GEAR2_HELP),
          option text = STRING_TOKEN (STR_GEAR1_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_GEAR2_STRING), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Hide if DDR Speed Control is Auto or if SAGV is not Enabled / FixedMid
      suppressif (NOT ideqval SA_SETUP.SaGv == 2 AND
                  NOT ideqval SA_SETUP.SaGv == 4) OR
                 NOT ideqval SA_SETUP.DdrSpeedControl == 1;
        oneof varid  = SA_SETUP.SaGvMidGear2,
          prompt     = STRING_TOKEN (STR_SAGV_MID_GEAR2_PROMPT),
          help       = STRING_TOKEN (STR_SAGV_MID_GEAR2_HELP),
          option text = STRING_TOKEN (STR_GEAR1_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_GEAR2_STRING), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Hide if DDR Speed Control is Auto
      suppressif NOT ideqval SA_SETUP.DdrSpeedControl == 1;
        oneof varid  = SA_SETUP.SaGvHighGear2,
          prompt     = STRING_TOKEN (STR_SAGV_HIGH_GEAR2_PROMPT),
          help       = STRING_TOKEN (STR_SAGV_HIGH_GEAR2_HELP),
          option text = STRING_TOKEN (STR_GEAR1_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_GEAR2_STRING), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid   = SA_SETUP.RetrainOnFastFail,
        prompt      = STRING_TOKEN(STR_RETRAIN_ON_FAST_FAIL_PROMPT),
        help        = STRING_TOKEN(STR_RETRAIN_ON_FAST_FAIL_HELP),
        option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.Ddr4OneDpc,
        prompt      = STRING_TOKEN(STR_DDR4_ONE_DPC_PROMPT),
        help        = STRING_TOKEN(STR_DDR4_ONE_DPC_HELP),
        option text = STRING_TOKEN(STR_DISABLED_STRING),      value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED_DIMM0_STRING), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED_DIMM1_STRING), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED_STRING),       value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;


      oneof varid    = SA_SETUP.RhPrevention,
        prompt   = STRING_TOKEN(STR_RH_PREVENTION_PROMPT),
        help     = STRING_TOKEN(STR_RH_PREVENTION_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval SA_SETUP.RhPrevention == 0;
        oneof varid    = SA_SETUP.RhSolution,
          prompt   = STRING_TOKEN(STR_RH_SOLUTION_PROMPT),
          help     = STRING_TOKEN(STR_RH_SOLUTION_HELP),
          option text = STRING_TOKEN (STR_HARDWARE_RHP), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_2X_REFRESH), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ((ideqval SA_SETUP.RhPrevention == 0) OR (ideqval SA_SETUP.RhSolution == 1));
        oneof varid    = SA_SETUP.RhActProbability,
          prompt   = STRING_TOKEN(STR_RH_ACT_PROBABILITY_PROMPT),
          help     = STRING_TOKEN(STR_RH_ACT_PROBABILITY_HELP),
          option text = STRING_TOKEN (STR_1_IN_2_TO_1),  value = 1,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_2),  value = 2,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_3),  value = 3,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_4),  value = 4,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_5),  value = 5,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_6),  value = 6,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_7),  value = 7,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_8),  value = 8,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_9),  value = 9,  flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_10), value = 10, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_11), value = 11, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_12), value = 12, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_13), value = 13, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_14), value = 14, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IN_2_TO_15), value = 15, flags = RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid    = SA_SETUP.ExitOnFailure,
        prompt   = STRING_TOKEN(STR_EXIT_ON_FAIL_PROMPT),
        help     = STRING_TOKEN(STR_EXIT_ON_FAIL_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   =  SA_SETUP.IedMemEnable,
        prompt   = STRING_TOKEN(STR_IED_MEMORY_ENABLE_PROMPT),
        help     = STRING_TOKEN(STR_IED_MEMORY_ENABLE_HELP),
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

        oneof varid  = SA_SETUP.ChHashEnable,
          prompt   = STRING_TOKEN (STR_CH_HASH_SUPPORT_PROMPT),
          help     = STRING_TOKEN (STR_CH_HASH_SUPPORT_HELP),
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        numeric varid  = SA_SETUP.ChHashMask,
          prompt   = STRING_TOKEN (STR_CH_HASH_MASK_SUPPORT_PROMPT),
          help     = STRING_TOKEN (STR_CH_HASH_MASK_SUPPORT_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0x0001,  // Minimum is BIT6
          maximum = 0x3FFF,  // Maximum is BITS 19-6
          step    = 1,
          default = 0x30CC,
        endnumeric;

      oneof varid  = SA_SETUP.ChHashInterleaveBit,
        prompt   = STRING_TOKEN (STR_CH_HASH_INTLVED_BIT_SUPPORT_PROMPT),
        help     = STRING_TOKEN (STR_CH_HASH_INTLVED_BIT_SUPPORT_HELP),
        option text = STRING_TOKEN (STR_BIT6_STRING),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_BIT7_STRING),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_BIT8_STRING),  value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_BIT9_STRING),  value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_BIT10_STRING), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_BIT11_STRING), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_BIT12_STRING), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_BIT13_STRING), value = 7, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.ExtendedBankHashing,
        prompt      = STRING_TOKEN (STR_EXTENDED_BANK_HASHING),
        help        = STRING_TOKEN (STR_EXTENDED_BANK_HASHING),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid  = SA_SETUP.PerBankRefresh,
        prompt    = STRING_TOKEN (STR_PER_BANK_REFRESH_PROMPT),
        help      = STRING_TOKEN (STR_PER_BANK_REFRESH_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
      grayoutif ideqval SETUP_DATA.TccMode == 1;
        oneof varid  = SA_SETUP.DisPgCloseIdleTimeout,
          questionid = PAGE_IDLE_TIMEOUT_QUESTION_ID,
          prompt   = STRING_TOKEN (STR_PAGE_IDLE_TIMEOUT_PROMPT),
          help     = STRING_TOKEN (STR_PAGE_IDLE_TIMEOUT_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING),        value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING),       value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid  = SA_SETUP.ScramblerSupport,
        prompt   = STRING_TOKEN (STR_MEMORY_SCRAMBLER_PROMPT),
        help     = STRING_TOKEN (STR_MEMORY_SCRAMBLER_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;


      oneof varid  = SA_SETUP.ForceColdReset,
        prompt   = STRING_TOKEN (STR_FORCE_COLDRESET_PROMPT),
        help     = STRING_TOKEN (STR_FORCE_COLDRESET_HELP),
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid  = SA_SETUP.DisableDimmMc0Ch0,
        prompt   = STRING_TOKEN (STR_DISABLE_MC0_CH0_DIMM_PROMPT),
        help     = STRING_TOKEN (STR_DISABLE_MC0_CH0_DIMM_HELP),
        option text = STRING_TOKEN(STR_ENABLE_BOTH_DIMM_STRING),      value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLE_DIMM0_STRING),         value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLE_DIMM1_STRING),         value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLE_BOTH_DIMM_STRING),     value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid  = SA_SETUP.DisableDimmMc0Ch1,
        prompt   = STRING_TOKEN (STR_DISABLE_MC0_CH1_DIMM_PROMPT),
        help     = STRING_TOKEN (STR_DISABLE_MC0_CH1_DIMM_HELP),
        option text = STRING_TOKEN(STR_ENABLE_BOTH_DIMM_STRING),      value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLE_DIMM0_STRING),         value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLE_DIMM1_STRING),         value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLE_BOTH_DIMM_STRING),     value = 3, flags = RESET_REQUIRED;
      endoneof;

      oneof varid  = SA_SETUP.ForceSingleRank,
        prompt   = STRING_TOKEN (STR_FORCE_SINGLE_RANK_PROMPT),
        help     = STRING_TOKEN (STR_FORCE_SINGLE_RANK_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid  = SA_SETUP.ForceSingleSubchannel,
        prompt   = STRING_TOKEN (STR_FORCE_SINGLE_SUB_CHANNEL_PROMPT),
        help     = STRING_TOKEN (STR_FORCE_SINGLE_SUB_CHANNEL_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      //
      // Ibecc
      //
      oneof varid   =  SA_SETUP.Ibecc,
        prompt      = STRING_TOKEN(STR_IBECC_PROMPT),
        help        = STRING_TOKEN(STR_IBECC_HELP),
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif ideqval SA_SETUP.Ibecc == 0x0;
        oneof varid  = SA_SETUP.IbeccOperationMode,
          prompt   = STRING_TOKEN (STR_IBECC_OPMODE_PROMPT),
          help     = STRING_TOKEN (STR_IBECC_OPMODE_PROMPT_HELP),
          option text = STRING_TOKEN (STR_0_IBECC_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_1_IBECC_STRING), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_2_IBECC_STRING), value = 2, flags = RESET_REQUIRED;
        endoneof;

        suppressif NOT ideqval SA_SETUP.IbeccOperationMode == 0x0; // IBECC Mode 0
          oneof varid  = SA_SETUP.IbeccProtectedRegionEnable[OFFSET_0],
            prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_0_ENABLE_PROMPT),
            help     = STRING_TOKEN (STR_IBECC_PROTECTED_0_ENABLE_PROMPT_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          endoneof;

          suppressif ideqval SA_SETUP.IbeccProtectedRegionEnable[OFFSET_0] == 0x0;
            numeric varid  = SA_SETUP.IbeccProtectedRegionBase[OFFSET_0],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_0_BASE_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_0_BASE_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0000,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x0,
            endnumeric;

            numeric varid  = SA_SETUP.IbeccProtectedRegionMask[OFFSET_0],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_0_MASK_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_0_MASK_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0001,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3F00,
            endnumeric;
          endif;

          oneof varid  = SA_SETUP.IbeccProtectedRegionEnable[OFFSET_1],
            prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_1_ENABLE_PROMPT),
            help     = STRING_TOKEN (STR_IBECC_PROTECTED_1_ENABLE_PROMPT_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          endoneof;

          suppressif ideqval SA_SETUP.IbeccProtectedRegionEnable[OFFSET_1] == 0x0;
            numeric varid  = SA_SETUP.IbeccProtectedRegionBase[OFFSET_1],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_1_BASE_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_1_BASE_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0000,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x100,
            endnumeric;

            numeric varid  = SA_SETUP.IbeccProtectedRegionMask[OFFSET_1],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_1_MASK_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_1_MASK_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0001,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FE0,
            endnumeric;
          endif;

          oneof varid  = SA_SETUP.IbeccProtectedRegionEnable[OFFSET_2],
            prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_2_ENABLE_PROMPT),
            help     = STRING_TOKEN (STR_IBECC_PROTECTED_2_ENABLE_PROMPT_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          endoneof;

          suppressif ideqval SA_SETUP.IbeccProtectedRegionEnable[OFFSET_2] == 0x0;
            numeric varid  = SA_SETUP.IbeccProtectedRegionBase[OFFSET_2],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_2_BASE_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_2_BASE_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0000,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;

            numeric varid  = SA_SETUP.IbeccProtectedRegionMask[OFFSET_2],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_2_MASK_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_2_MASK_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0001,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;
          endif;

          oneof varid  = SA_SETUP.IbeccProtectedRegionEnable[OFFSET_3],
            prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_3_ENABLE_PROMPT),
            help     = STRING_TOKEN (STR_IBECC_PROTECTED_3_ENABLE_PROMPT_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          endoneof;

          suppressif ideqval SA_SETUP.IbeccProtectedRegionEnable[OFFSET_3] == 0x0;
            numeric varid  = SA_SETUP.IbeccProtectedRegionBase[OFFSET_3],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_3_BASE_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_3_BASE_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0000,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;

            numeric varid  = SA_SETUP.IbeccProtectedRegionMask[OFFSET_3],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_3_MASK_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_3_MASK_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0001,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;
          endif;

          oneof varid  = SA_SETUP.IbeccProtectedRegionEnable[OFFSET_4],
            prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_4_ENABLE_PROMPT),
            help     = STRING_TOKEN (STR_IBECC_PROTECTED_4_ENABLE_PROMPT_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          endoneof;

          suppressif ideqval SA_SETUP.IbeccProtectedRegionEnable[OFFSET_4] == 0x0;
            numeric varid  = SA_SETUP.IbeccProtectedRegionBase[OFFSET_4],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_4_BASE_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_4_BASE_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0000,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;

            numeric varid  = SA_SETUP.IbeccProtectedRegionMask[OFFSET_4],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_4_MASK_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_4_MASK_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0001,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;
          endif;

          oneof varid  = SA_SETUP.IbeccProtectedRegionEnable[OFFSET_5],
            prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_5_ENABLE_PROMPT),
            help     = STRING_TOKEN (STR_IBECC_PROTECTED_5_ENABLE_PROMPT_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          endoneof;

          suppressif ideqval SA_SETUP.IbeccProtectedRegionEnable[OFFSET_5] == 0x0;
            numeric varid  = SA_SETUP.IbeccProtectedRegionBase[OFFSET_5],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_5_BASE_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_5_BASE_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0000,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;

            numeric varid  = SA_SETUP.IbeccProtectedRegionMask[OFFSET_5],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_5_MASK_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_5_MASK_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0001,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;
          endif;

          oneof varid  = SA_SETUP.IbeccProtectedRegionEnable[OFFSET_6],
            prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_6_ENABLE_PROMPT),
            help     = STRING_TOKEN (STR_IBECC_PROTECTED_6_ENABLE_PROMPT_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          endoneof;

          suppressif ideqval SA_SETUP.IbeccProtectedRegionEnable[OFFSET_6] == 0x0;
            numeric varid  = SA_SETUP.IbeccProtectedRegionBase[OFFSET_6],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_6_BASE_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_6_BASE_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0000,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;

            numeric varid  = SA_SETUP.IbeccProtectedRegionMask[OFFSET_6],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_6_MASK_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_6_MASK_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0001,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;
          endif;

          oneof varid  = SA_SETUP.IbeccProtectedRegionEnable[OFFSET_7],
            prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_7_ENABLE_PROMPT),
            help     = STRING_TOKEN (STR_IBECC_PROTECTED_7_ENABLE_PROMPT_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          endoneof;

          suppressif ideqval SA_SETUP.IbeccProtectedRegionEnable[OFFSET_7] == 0x0;
            numeric varid  = SA_SETUP.IbeccProtectedRegionBase[OFFSET_7],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_7_BASE_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_7_BASE_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0000,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;

            numeric varid  = SA_SETUP.IbeccProtectedRegionMask[OFFSET_7],
              prompt   = STRING_TOKEN (STR_IBECC_PROTECTED_7_MASK_PROMPT),
              help     = STRING_TOKEN (STR_IBECC_PROTECTED_7_MASK_PROMPT_HELP),
              flags   = RESET_REQUIRED,
              minimum = 0x0001,
              maximum = 0x3FFF,
              step    = 1,
              default = 0x3FFF,
            endnumeric;
          endif;
        endif;
      endif;

      oneof varid  = SA_SETUP.RemapEnable,
        prompt   = STRING_TOKEN (STR_REMAP_ENABLE_PROMPT),
        help     = STRING_TOKEN (STR_REMAP_ENABLE_PROMPT_HELP),
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
      endoneof;

      oneof varid  = SA_SETUP.MrcTimeMeasure,
        prompt   = STRING_TOKEN (STR_TIME_MEASURE_PROMPT),
        help     = STRING_TOKEN (STR_TIME_MEASURE_PROMPT_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
      endoneof;

    oneof varid  = SA_SETUP.MrcFastBoot,
        prompt   = STRING_TOKEN (STR_MRC_FAST_BOOT_ENABLE_PROMPT),
        help     = STRING_TOKEN (STR_MRC_FAST_BOOT_ENABLE_PROMPT_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

    oneof varid  = SA_SETUP.MrcTrainOnWarm,
      prompt   = STRING_TOKEN (STR_MRC_TRAIN_ON_WARM_PROMPT),
      help     = STRING_TOKEN (STR_MRC_TRAIN_ON_WARM_PROMPT_HELP),
      option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid  = SA_SETUP.RmtPerTask,
      prompt   = STRING_TOKEN (STR_RMT_PER_TASK_PROMPT),
      help     = STRING_TOKEN (STR_RMT_PER_TASK_HELP),
      option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid  = SA_SETUP.TrainTrace,
      prompt   = STRING_TOKEN (STR_TRAIN_TRACE_PROMPT),
      help     = STRING_TOKEN (STR_TRAIN_TRACE_HELP),
      option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid  = SA_SETUP.LpddrMemWriteLatencySet,
      prompt   = STRING_TOKEN (STR_LPDDR_MEM_WL_SET_PROMPT),
      help     = STRING_TOKEN (STR_LPDDR_MEM_WL_SET_HELP),
      option text = STRING_TOKEN (STR_SET_A), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN (STR_SET_B), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    grayoutif ideqval SA_SETUP.BdatEnable == 0x0;
      oneof varid   = SA_SETUP.BdatTestType,
        prompt      = STRING_TOKEN(STR_BDAT_TEST_TYPE_PROMPT),
        help        = STRING_TOKEN(STR_BDAT_TEST_TYPE_HELP),
        option text = STRING_TOKEN(STR_BDAT_TEST_TYPE_RMT_RANK),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_BDAT_TEST_TYPE_RMT_BIT),   value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_BDAT_TEST_TYPE_MARGIN_2D), value = 2, flags = RESET_REQUIRED;
      endoneof;
    endif;

    numeric varid = SA_SETUP.RMTLoopCount,
      prompt      = STRING_TOKEN(STR_RMT_LOOPCOUNT_PROMPT),
      help        = STRING_TOKEN(STR_RMT_LOOPCOUNT_HELP),
      flags       = RESET_REQUIRED,
      minimum     = 0,
      maximum     = 32,
      step        = 1,
      default     = 0, // Auto
    endnumeric;

    oneof varid    = SA_SETUP.LowSupplyEnData,
      prompt      = STRING_TOKEN(STR_LOW_SUPPLY_EN_DATA),
      help        = STRING_TOKEN(STR_LOW_SUPPLY_EN_DATA),
      option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid    = SA_SETUP.LowSupplyEnCcc,
      prompt      = STRING_TOKEN(STR_LOW_SUPPLY_EN_CCC),
      help        = STRING_TOKEN(STR_LOW_SUPPLY_EN_CCC),
      option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
    endoneof;

    oneof varid  = SA_SETUP.MemTestOnWarmBoot,
      prompt   = STRING_TOKEN (STR_MEMTEST_WARMBOOT_SUPPORT_PROMPT),
      help     = STRING_TOKEN (STR_MEMTEST_WARMBOOT_SUPPORT_HELP),
      option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
    endoneof;

    endform;

    form formid = AUTO_ID(NB_FORM_ID),
    title = STRING_TOKEN(STR_NB_FORM);

      SUBTITLE(STRING_TOKEN(STR_NB_FORM))
      SEPARATOR

      text
        help   = STRING_TOKEN(STR_SA_VTD_HELP),
        text   = STRING_TOKEN(STR_SA_VTD_STRING),
        text   = STRING_TOKEN(STR_SA_VTD_VALUE),
        flags  = 0,
        key    = 0;

      SEPARATOR

      goto IGFX_FORM_ID,
        prompt  = STRING_TOKEN(STR_IGFX),
        help    = STRING_TOKEN(STR_IGFX);

      goto SA_DISPLAY_OPTIONS_FORM_ID,
        prompt  = STRING_TOKEN(STR_SA_DISPLAY_OPTIONS_FORM_TITLE),
        help    = STRING_TOKEN(STR_SA_DISPLAY_OPTIONS_FORM_HELP);

      //
      // Vt-d BIOS Option
      //
      suppressif  ideqval SETUP_VOLATILE_DATA.VTdAvailable == 0;
        grayoutif ideqval SETUP_VOLATILE_DATA.TbtVtdBaseSecurityGrayOut == 1;
          grayoutif ideqval SETUP_DATA.TccMode == 1;
            oneof varid    = SA_SETUP.EnableVtd,
              questionid  = AUTO_ID(SA_VTD_QUESTION_ID),
              prompt      = STRING_TOKEN(STR_SA_VTD_PROMPT),
              help        = STRING_TOKEN(STR_SA_VTD_HELP),
              option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
              option text = STRING_TOKEN(STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            endoneof;
          endif; //TccModeGrayOut
        endif; //TbtVtdBaseSecurityGrayOut
      endif; //VTdAvailable

      grayoutif ideqval SETUP_VOLATILE_DATA.VTdAvailable == 0
                  OR ideqval SA_SETUP.EnableVtd == 0;
      suppressif  ideqval SETUP_CPU_FEATURES.LocalX2ApicAvailable == 0;
        oneof varid   =  SA_SETUP.X2ApicOptOut,
          prompt   = STRING_TOKEN(STR_X2APIC_OPT_OUT_PROMPT),
          help     = STRING_TOKEN(STR_X2APIC_OPT_OUT_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        endoneof;
      endif;
        oneof varid   =  SA_SETUP.DmaControlGuarantee,
          prompt   = STRING_TOKEN(STR_DMA_CONTROL_GUARANTEE_PROMPT),
          help     = STRING_TOKEN(STR_DMA_CONTROL_GUARANTEE_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        oneof varid   =  SA_SETUP.VtdIgdEnable,
          prompt   = STRING_TOKEN(STR_VTD_IGD_PROMPT),
          help     = STRING_TOKEN(STR_VTD_IGD_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        endoneof;

        oneof varid   =  SA_SETUP.VtdIpuEnable,
          prompt   = STRING_TOKEN(STR_VTD_IPU_PROMPT),
          help     = STRING_TOKEN(STR_VTD_IPU_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        oneof varid   =  SA_SETUP.VtdIopEnable,
          prompt   = STRING_TOKEN(STR_VTD_IOP_PROMPT),
          help     = STRING_TOKEN(STR_VTD_IOP_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        endoneof;

        oneof varid   =  SA_SETUP.VtdItbtEnable,
          prompt   = STRING_TOKEN(STR_VTD_ITBT_PROMPT),
          help     = STRING_TOKEN(STR_VTD_ITBT_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid    = SA_SETUP.CpuCrashLogDevice,
        prompt   = STRING_TOKEN(STR_CPU_CRASHLOG_DEVICE_PROMPT),
        help     = STRING_TOKEN(STR_CPU_CRASHLOG_DEVICE_HELP),
        option text = STRING_TOKEN(STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
      endoneof;

      oneof varid    = SA_SETUP.GnaEnable,
        prompt   = STRING_TOKEN(STR_SA_GNA_DEVICE_PROMPT),
        help     = STRING_TOKEN(STR_SA_GNA_DEVICE_HELP),
        option text = STRING_TOKEN(STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
      endoneof;

      oneof varid    = SA_SETUP.CridEnable,
        prompt   = STRING_TOKEN(STR_SA_CRID_ENABLE_PROMPT),
        help     = STRING_TOKEN(STR_SA_CRID_ENABLE_HELP),
        option text = STRING_TOKEN(STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
      suppressif ideqval SA_SETUP.ApertureSize == 15;
        oneof varid   =  SA_SETUP.EnableAbove4GBMmio,
          prompt   = STRING_TOKEN(STR_MMIO_ABOVE_4G_PROMPT),
          help     = STRING_TOKEN(STR_MMIO_ABOVE_4G_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
        endoneof;
      endif;

      //
      // IPU BIOS Option
      //
    suppressif  ideqval SETUP_VOLATILE_DATA.IpuSupport == 0;

      oneof varid   =  SA_SETUP.SaIpuEnable,
        prompt   = STRING_TOKEN(STR_SA_IPU_DEVICE_PROMPT),
        help     = STRING_TOKEN(STR_SA_IPU_DEVICE_HELP),
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      suppressif  ideqval SA_SETUP.SaIpuEnable == 0;
        oneof varid   =  SA_SETUP.SaIpuImrConfiguration,
          prompt   = STRING_TOKEN(STR_SA_IPU_IMR_PROMPT),
          help     = STRING_TOKEN(STR_SA_IPU_IMR_HELP),
          option text = STRING_TOKEN (STR_SA_IPU_CAMERA),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_SA_IPU_GEN), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;


      oneof varid   =  SA_SETUP.SaIpuFusaConfigEnable,
        prompt   = STRING_TOKEN(STR_SA_IPU_FUSA_PROMPT),
        help     = STRING_TOKEN(STR_SA_IPU_FUSA_HELP),
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

    endif; // suppressif IpuSupport

        goto MIPICAM_OPTIONS_FORM_ID,
          prompt = STRING_TOKEN(STR_MIPICAM_OPTIONS_FORM_TITLE),
          help = STRING_TOKEN(STR_MIPICAM_OPTIONS_FORM_TITLE);

      suppressif NOT (ideqval CPU_SETUP_VOLATILE_DATA.EdramSupported == 1);
        oneof varid   = SA_SETUP.EdramTestMode,
          prompt      = STRING_TOKEN(STR_EDRAMWA_PROMPT),
          help        = STRING_TOKEN(STR_EDRAMWA_HELP),
          option text = STRING_TOKEN(STR_EDRAM_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_EDRAM_ENABLE), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_EDRAM_HW_MODE), value = 2, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;
    endform;

    form formid = AUTO_ID(IGFX_FORM_ID),
    title     = STRING_TOKEN(STR_IGFX);

      SUBTITLE(STRING_TOKEN(STR_IGFX))
      SEPARATOR

    suppressif ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;
        //
        // Graphics Turbo IMON Current setup option
        //
        numeric varid = SA_SETUP.GfxTurboIMON,
          prompt      = STRING_TOKEN (STR_GRAPHICS_TURBO_IMAX),
          help        = STRING_TOKEN (STR_GRAPHICS_TURBO_IMAX_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 14,
          maximum     = 31,
          step        = 1,
          default     = 31,  // default ICC_MAX value
        endnumeric;
    endif;

        oneof varid    = SA_SETUP.SkipExtGfxScan,
          prompt   = STRING_TOKEN(STR_SKIP_EXT_GFX_SCAN),
          help     = STRING_TOKEN(STR_SKIP_EXT_GFX_SCAN_HELP),
          option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        endoneof;

      SEPARATOR

      //
      // Primary Display setup option
      //
      suppressif (NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad ) OR
                   ((NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorMobile) AND
                    (NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorEmbedded) AND
                    (NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorDesktop) AND
                    (NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorWorkstation));

        oneof varid    = SA_SETUP.PrimaryDisplay,
          prompt   = STRING_TOKEN(STR_PRIMARY_DISPLAY),
          help     = STRING_TOKEN(STR_PRIMARY_DISPLAY_HELP),
          option text = STRING_TOKEN(STR_AUTO_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IGFX_STRING), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PEG_STRING),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_PCI_STRING),  value = 2, flags = RESET_REQUIRED;
        endoneof;
        oneof varid    = SA_SETUP.PcieCardSelect,   // Pcie Card selection.
          prompt   = STRING_TOKEN(STR_PCIE_CARD),
          help     = STRING_TOKEN(STR_PCIE_CARD_HELP),
          option text = STRING_TOKEN(STR_AUTO_STRING),  value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCIE_ELK_CREEK), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCIE_PEG_EVAL),  value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeUltUlx OR
                 ((NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorMobile) AND
                 (NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorEmbedded));
        oneof varid    = SA_SETUP.PrimaryDisplay,
          prompt   = STRING_TOKEN(STR_PRIMARY_DISPLAY),
          help     = STRING_TOKEN(STR_PRIMARY_DISPLAY_HELP),
          option text = STRING_TOKEN(STR_AUTO_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IGFX_STRING), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_PCI_STRING),  value = 2, flags = RESET_REQUIRED;
        endoneof;

        oneof varid    = SA_SETUP.PcieCardSelect,   // Pcie Card selection.
          prompt   = STRING_TOKEN(STR_PCIE_CARD),
          help     = STRING_TOKEN(STR_PCIE_CARD_HELP),
          option text = STRING_TOKEN(STR_AUTO_STRING),  value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCIE_ELK_CREEK), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCIE_PEG_EVAL),  value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;
      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;
        oneof varid    = SA_SETUP.PrimaryDisplay,
          prompt   = STRING_TOKEN(STR_PRIMARY_DISPLAY),
          help     = STRING_TOKEN(STR_PRIMARY_DISPLAY_HELP),
          option text = STRING_TOKEN(STR_AUTO_STRING), value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_IGFX_STRING), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PEG_STRING),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_PCH_PCI_STRING),  value = 2, flags = RESET_REQUIRED;
        endoneof;
      endif;

        oneof varid    = SA_SETUP.InternalGraphics,
          prompt   = STRING_TOKEN(STR_INT_GRAPHICS_PROMPT),
          help     = STRING_TOKEN(STR_INT_GRAPHICS_HELP),
          default  = 2, defaultstore = MyStandardDefault,
          option text = STRING_TOKEN(STR_AUTO_STRING), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        endoneof;

        oneof varid    = SA_SETUP.GTTSize,
          prompt   = STRING_TOKEN(STR_GTT_SIZE),
          help     = STRING_TOKEN(STR_GTT_SIZE_HELP),
          option text = STRING_TOKEN(GTT_SIZE_2MB), value = 1, flags =  RESET_REQUIRED;
          option text = STRING_TOKEN(GTT_SIZE_4MB), value = 2, flags =  RESET_REQUIRED;
          option text = STRING_TOKEN(GTT_SIZE_8MB), value = 3, flags =  DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        oneof varid    = SA_SETUP.ApertureSize,
          prompt   = STRING_TOKEN(STR_APERTURE_SIZE),
          help     = STRING_TOKEN(STR_APERTURE_SIZE_HELP),
          default value = 1, defaultstore = MyStandardDefault,
          option text = STRING_TOKEN(APERTURE_SIZE_128MB), value = 0, flags =  RESET_REQUIRED;
          option text = STRING_TOKEN(APERTURE_SIZE_256MB), value = 1, flags =  RESET_REQUIRED;
          option text = STRING_TOKEN(APERTURE_SIZE_512MB), value = 3, flags =  RESET_REQUIRED;
          option text = STRING_TOKEN(APERTURE_SIZE_1024MB), value = 7, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(APERTURE_SIZE_2048MB), value = 15, flags = RESET_REQUIRED;
        endoneof;

        oneof varid  = SA_SETUP.GtPsmiSupport,
          prompt   = STRING_TOKEN (STR_GT_PSMI_SUPPORT),
          help     = STRING_TOKEN (STR_GT_PSMI_SUPPORT_HELP),
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        endoneof;

        suppressif ideqval SA_SETUP.GtPsmiSupport == 0;
          oneof varid    = SA_SETUP.GtPsmiRegionSize,
            prompt   = STRING_TOKEN(STR_PSMI_REGION_SIZE),
            help     = STRING_TOKEN(STR_PSMI_REGION_SIZE_HELP),
            default value = 0, defaultstore = MyStandardDefault,
            option text = STRING_TOKEN(PSMI_REGION_SIZE_32MB), value = 0, flags =  RESET_REQUIRED;
            option text = STRING_TOKEN(PSMI_REGION_SIZE_288MB), value = 1, flags =  RESET_REQUIRED;
            option text = STRING_TOKEN(PSMI_REGION_SIZE_544MB), value = 2, flags =  RESET_REQUIRED;
            option text = STRING_TOKEN(PSMI_REGION_SIZE_800MB), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(PSMI_REGION_SIZE_1024MB), value = 4, flags = RESET_REQUIRED;
          endoneof;
        endif;

      //
      // IgdDvmt50PreAlloc for CNL CPU
      //

        oneof varid   = SA_SETUP.IgdDvmt50PreAlloc,
          prompt  = STRING_TOKEN(STR_DVMT50_PRE_ALLOC),
          help    = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_HELP),
          default =254 , defaultstore = MyStandardDefault,
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_0M), value=0, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_32M), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_64M), value=2, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_96M),  value=3, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_128M), value=4, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_160M), value=5, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_4M), value=240, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_8M), value=241, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_12M), value=242, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_16M), value=243, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_20M), value=244, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_24M), value=245, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_28M), value=246, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_32M_F7), value=247, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_36M), value=248, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_40M), value=249, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_44M), value=250, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_48M), value=251, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_52M), value=252, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_56M), value=253, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_PRE_ALLOC_60M), value=254, flags=RESET_REQUIRED;
        endoneof;

        oneof   varid   = SA_SETUP.IgdDvmt50TotalAlloc,
          prompt  = STRING_TOKEN(STR_DVMT50_DVMT ),
          help    = STRING_TOKEN(STR_DVMT50_DVMT_HELP),
          default = 2, defaultstore = MyStandardDefault,
          option text = STRING_TOKEN(STR_DVMT50_ALLOC_128), value=1, flags=RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_ALLOC_256), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DVMT50_ALLOC_MAX), value=3, flags=RESET_REQUIRED;
        endoneof;


        //
        // @todo : Suppress the DiSM policy when 2LM is not supported
        //         Adjust the DiSM size based on near memory size variable
        //
        oneof varid   = SA_SETUP.DismSize,
          prompt   = STRING_TOKEN (STR_DISM_SIZE),
          help     = STRING_TOKEN (STR_DISM_SIZE_HELP),
          option text = STRING_TOKEN (DISM_REGION_SIZE_0GB), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (DISM_REGION_SIZE_1GB), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (DISM_REGION_SIZE_2GB), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (DISM_REGION_SIZE_3GB), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (DISM_REGION_SIZE_4GB), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (DISM_REGION_SIZE_5GB), value = 5, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (DISM_REGION_SIZE_6GB), value = 6, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (DISM_REGION_SIZE_7GB), value = 7, flags = RESET_REQUIRED;
        endoneof;

        oneof   varid   = SA_SETUP.PeiGraphicsPeimInit,
          prompt  = STRING_TOKEN(STR_PEI_DISPLAY),
          help    = STRING_TOKEN(STR_PEI_DISPLAY_HELP),
#if FixedPcdGetBool(PcdFspWrapperEnable) == 1
          option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
#else
          option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
#endif
        endoneof;

      //
      // ALS support is via ISH vs GFX driver without bios intervention
      // Remvoing the ALS support setup option (Code is kept for supporting ALS via EC only if design supports it)
      //
      suppressif TRUE;
        oneof varid  = SA_SETUP.AlsEnable,
          prompt   = STRING_TOKEN (STR_ACPI_ALS_ENABLE),
          help     = STRING_TOKEN (STR_ACPI_ALS_ENABLE_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;
          oneof varid  = SA_SETUP.PanelPowerEnable,
            prompt   = STRING_TOKEN (STR_PANEL_POWER),
            help     = STRING_TOKEN (STR_PANEL_POWER_HELP),
            option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          endoneof;
      endif;  // suppressif ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;

      grayoutif ideqval SETUP_DATA.TccMode == 1;
        oneof   varid   = SA_SETUP.PmSupport,
          questionid  = AUTO_ID(SA_PM_SUPPORT_QUESTION_ID),
          prompt  = STRING_TOKEN(STR_PM_SUPPORT),
          help    = STRING_TOKEN(STR_PM_SUPPORT_HELP),
          option text = STRING_TOKEN(STR_ENABLED_STRING), value= 1, flags=  DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED_STRING), value= 0, flags= RESET_REQUIRED;
        endoneof;
      endif;

      oneof   varid   = SA_SETUP.PavpEnable,
        prompt  = STRING_TOKEN(STR_PAVP_ENABLE),
        help    = STRING_TOKEN(STR_PAVP_ENABLE_HELP),
        option text = STRING_TOKEN(STR_ENABLED_STRING), value=1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED_STRING), value=0, flags = RESET_REQUIRED;
      endoneof;

      oneof   varid   = SA_SETUP.CdynmaxClampEnable,
        prompt  = STRING_TOKEN(STR_CDYNMAX_CLAMP_ENABLE),
        help    = STRING_TOKEN(STR_CDYNMAX_CLAMP_ENABLE_HELP),
        option text = STRING_TOKEN(STR_ENABLED_STRING), value=1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED_STRING), value=0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;


      // For 24MHz
      suppressif (ideqval SETUP_VOLATILE_DATA.CdClockSelector == 1 OR ideqval SETUP_VOLATILE_DATA.CdClockSelector == 0);
        oneof   varid   = SA_SETUP.CdClock,
          prompt  = STRING_TOKEN(STR_CD_CLOCK),
          help    = STRING_TOKEN(STR_CD_CLOCK_HELP),
          option text = STRING_TOKEN(STR_CD_CLOCK_312), value= 1, flags= RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CD_CLOCK_552), value= 2, flags= RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CD_CLOCK_648), value= 4, flags= RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CD_CLOCK_PLAT_MAX), value= 0xFF, flags= DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

    // For 19.2MHz or 38.4MHz
     suppressif ideqval SETUP_VOLATILE_DATA.CdClockSelector == 2;
       oneof   varid   = SA_SETUP.CdClock,
         prompt  = STRING_TOKEN(STR_CD_CLOCK),
         help    = STRING_TOKEN(STR_CD_CLOCK_HELP),
         option text = STRING_TOKEN(STR_CD_CLOCK_307_2), value=0, flags= RESET_REQUIRED;
         option text = STRING_TOKEN(STR_CD_CLOCK_556_8), value= 3, flags= RESET_REQUIRED;
         option text = STRING_TOKEN(STR_CD_CLOCK_652_8), value= 5, flags= RESET_REQUIRED;
         option text = STRING_TOKEN(STR_CD_CLOCK_PLAT_MAX), value= 0xFF, flags= DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;
     endif;

      oneof varid     = SA_SETUP.SkipCdClockInit,
        prompt  = STRING_TOKEN(STR_SKIP_CD_CLK_INIT),
        help    = STRING_TOKEN(STR_SKIP_CD_CLK_INIT_HELP),
        option text = STRING_TOKEN(STR_ENABLED_STRING), value=1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED_STRING), value=0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;


    oneof varid    = SA_SETUP.VbtSelect,
      prompt   = STRING_TOKEN(STR_VBT_SELECT_PROMPT),
      help     = STRING_TOKEN(STR_VBT_SELECT_HELP),
      option text = STRING_TOKEN(STR_VBT_EDP), value = VBT_SELECT_EDP, flags = DEFAULT | RESET_REQUIRED;
      option text = STRING_TOKEN(STR_VBT_MIPI), value = VBT_SELECT_MIPI, flags = RESET_REQUIRED;
    endoneof;

    oneof varid = SA_SETUP.IuerButtonEnable,
      prompt   = STRING_TOKEN(STR_IUER_BUTTON_ENABLE),
      help     = STRING_TOKEN(STR_IUER_BUTTON_ENABLE_HELP),
      default  = 0, defaultstore = MyStandardDefault,
      option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED_STRING), value = 1, flags = RESET_REQUIRED;
    endoneof;

      suppressif ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer OR
                 ideqval SETUP_DATA.CsmControl == 1 OR
                 ideqval SETUP_DATA.CsmControl == 2;
        goto IGFX_LCD_FORM_ID,
          prompt  = STRING_TOKEN(STR_IGFX_LCD),
          help    = STRING_TOKEN(STR_IGFX_LCD);
      endif;

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorMobile;
        goto IGFX_IUER_FORM_ID,
          prompt  = STRING_TOKEN(STR_IUER_SUPPORT_STRING),
          help    = STRING_TOKEN(STR_IUER_SUPPORT_STRING);
      endif;  // suppres if NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorMobile

    endform;

    form formid = AUTO_ID(COMMON_NB_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_NB_OPTIONS_FORM_TITLE);

      SUBTITLE(STRING_TOKEN(STR_NB_OPTIONS_FORM_TITLE))
      SEPARATOR

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad;
        text
          help   = STRING_TOKEN(STR_DMI_INFO_HELP),
          text   = STRING_TOKEN(STR_DMI_INFO_NAME),
          text   = STRING_TOKEN(STR_DMI_INFO_VALUE),
          flags  = 0,
          key    = 0;

        SEPARATOR

        oneof varid   = SA_SETUP.DmiMaxLinkSpeed,
          prompt      = STRING_TOKEN(STR_DMI_MAX_SPEED_PROMPT),
          help        = STRING_TOKEN(STR_DMI_MAX_SPEED_HELP),
          option text = STRING_TOKEN (STR_AUTO_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_GEN1),        value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_GEN2),        value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_GEN3),        value = 3, flags = RESET_REQUIRED;
        endoneof;

        oneof varid   = SA_SETUP.DmiGen3EqPh2Enable,
          prompt      = STRING_TOKEN(STR_DMI_GEN3_EQ_PHASE2_PROMPT),
          help        = STRING_TOKEN(STR_GEN3_EQ_PHASE2_HELP),
          option text = STRING_TOKEN(STR_DISABLED_STRING),       value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED_STRING),        value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_AUTO_STRING),           value = 2, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          inconsistentif
            prompt    = STRING_TOKEN(STR_EQ_PH2_PH3_INCONSISTENT_PROMPT),
            ideqval SA_SETUP.DmiGen3EqPh2Enable == 0 AND ideqval SA_SETUP.DmiGen3EqPh3Method == 1
          endif
        endoneof;

        oneof varid   = SA_SETUP.DmiGen3EqPh3Method,
          prompt      = STRING_TOKEN(STR_DMI_GEN3_EQ_PHASE3_METHOD_PROMPT),
          help        = STRING_TOKEN(STR_GEN3_EQ_PHASE3_METHOD_HELP),
          option text = STRING_TOKEN (STR_AUTO_STRING),           value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_EQ_PH3_METHOD_HWEQ),    value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_EQ_PH3_METHOD_SWEQ),    value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_EQ_PH3_METHOD_STATIC),  value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING),      value = 4, flags = RESET_REQUIRED;
          inconsistentif
            prompt    = STRING_TOKEN(STR_EQ_PH2_PH3_INCONSISTENT_PROMPT),
            ideqval SA_SETUP.DmiGen3EqPh2Enable == 0 AND ideqval SA_SETUP.DmiGen3EqPh3Method == 1
          endif
        endoneof;
      endif;

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeTrad;
        oneof varid   = SA_SETUP.DmiGen3ProgramStaticEq,
          prompt      = STRING_TOKEN(STR_DMI_GEN3_EQ_PROMPT),
          help        = STRING_TOKEN(STR_PEG_GEN3_EQ_HELP),
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;

        suppressif ideqval SA_SETUP.DmiGen3ProgramStaticEq == 0;

          goto DMI_GEN3_RP_PRESET_FORM_ID,
            prompt = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_PROMPT),
            help   = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_HELP);

          goto DMI_GEN3_EP_PRESET_FORM_ID,
            prompt = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_PROMPT),
            help   = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_HELP);

          goto DMI_GEN3_EP_HINT_FORM_ID,
            prompt = STRING_TOKEN(STR_GEN3_END_POINT_HINT_PROMPT),
            help   = STRING_TOKEN(STR_GEN3_END_POINT_HINT_HELP);

        endif;

        goto DMI_GEN3_RX_CTLE_CONTROL_FORM_ID,
          prompt = STRING_TOKEN(STR_GEN3_RX_CTLE_CONTROL_PROMPT),
          help   = STRING_TOKEN(STR_GEN3_RX_CTLE_CONTROL_HELP);

        oneof varid = SA_SETUP.DmiDeEmphasis,
          prompt   = STRING_TOKEN(STR_DMI_DE_EMPHASIS_PROMPT),
          help     = STRING_TOKEN(STR_DMI_DE_EMPHASIS_HELP),
          option text  = STRING_TOKEN (STR_6DB_STRING),  value = 0, flags = RESET_REQUIRED;
          option text  = STRING_TOKEN (STR_35DB_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;
    endform;



    form formid = AUTO_ID(DMI_GEN3_RP_PRESET_FORM_ID),
    title       = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_PROMPT);

      SUBTITLE(STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_PROMPT))
      SEPARATOR

      numeric varid = SA_SETUP.DmiGen3RootPortPreset[OFFSET_0],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_ROOT_PORT_PRESET_LANE0_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_LANE0_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 8,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RootPortPreset[OFFSET_1],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_ROOT_PORT_PRESET_LANE1_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_LANE1_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 8,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RootPortPreset[OFFSET_2],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_ROOT_PORT_PRESET_LANE2_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_LANE2_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 8,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RootPortPreset[OFFSET_3],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_ROOT_PORT_PRESET_LANE3_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_LANE3_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 8,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RootPortPreset[OFFSET_4],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_ROOT_PORT_PRESET_LANE4_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_LANE4_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 8,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RootPortPreset[OFFSET_5],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_ROOT_PORT_PRESET_LANE5_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_LANE5_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 8,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RootPortPreset[OFFSET_6],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_ROOT_PORT_PRESET_LANE6_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_LANE6_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 8,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RootPortPreset[OFFSET_7],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_ROOT_PORT_PRESET_LANE7_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_ROOT_PORT_PRESET_LANE7_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 8,
      endnumeric;
    endform;

    form formid = AUTO_ID(DMI_GEN3_EP_PRESET_FORM_ID),
    title       = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_PROMPT);

      SUBTITLE(STRING_TOKEN(STR_GEN3_END_POINT_PRESET_PROMPT))
      SEPARATOR

      numeric varid = SA_SETUP.DmiGen3EndPointPreset[OFFSET_0],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_PRESET_LANE0_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_LANE0_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 7,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointPreset[OFFSET_1],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_PRESET_LANE1_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_LANE1_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 7,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointPreset[OFFSET_2],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_PRESET_LANE2_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_LANE2_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 7,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointPreset[OFFSET_3],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_PRESET_LANE3_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_LANE3_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 7,
      endnumeric;

      numeric varid = SA_SETUP.DmiGen3EndPointPreset[OFFSET_4],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_PRESET_LANE4_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_LANE4_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 7,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointPreset[OFFSET_5],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_PRESET_LANE5_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_LANE5_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 7,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointPreset[OFFSET_6],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_PRESET_LANE6_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_LANE6_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 7,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointPreset[OFFSET_7],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_PRESET_LANE7_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_PRESET_LANE7_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 9,
        step        = 1,
        default     = 7,
      endnumeric;
    endform;

    form formid = AUTO_ID(DMI_GEN3_EP_HINT_FORM_ID),
    title       = STRING_TOKEN(STR_GEN3_END_POINT_HINT_PROMPT);

      SUBTITLE(STRING_TOKEN(STR_GEN3_END_POINT_HINT_PROMPT))
      SEPARATOR

      numeric varid = SA_SETUP.DmiGen3EndPointHint[OFFSET_0],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_HINT_LANE0_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_HINT_LANE0_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 6,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointHint[OFFSET_1],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_HINT_LANE1_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_HINT_LANE1_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 6,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointHint[OFFSET_2],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_HINT_LANE2_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_HINT_LANE2_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 6,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointHint[OFFSET_3],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_HINT_LANE3_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_HINT_LANE3_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 6,
        step        = 1,
        default     = 2,
      endnumeric;

      numeric varid = SA_SETUP.DmiGen3EndPointHint[OFFSET_4],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_HINT_LANE4_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_HINT_LANE4_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 6,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointHint[OFFSET_5],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_HINT_LANE5_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_HINT_LANE5_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 6,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointHint[OFFSET_6],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_HINT_LANE6_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_HINT_LANE6_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 6,
        step        = 1,
        default     = 2,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3EndPointHint[OFFSET_7],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_END_POINT_HINT_LANE7_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_END_POINT_HINT_LANE7_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 6,
        step        = 1,
        default     = 2,
      endnumeric;
    endform;

    form formid = AUTO_ID(DMI_GEN3_RX_CTLE_CONTROL_FORM_ID),
    title       = STRING_TOKEN(STR_GEN3_RX_CTLE_CONTROL_PROMPT);

      SUBTITLE(STRING_TOKEN(STR_GEN3_RX_CTLE_CONTROL_PROMPT))
      SEPARATOR

      numeric varid = SA_SETUP.DmiGen3RxCtlePeaking[OFFSET_0],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_RX_CTLE_BUNDLE0_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_RX_CTLE_BUNDLE0_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 15,
        step        = 1,
        default     = 0,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RxCtlePeaking[OFFSET_1],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_RX_CTLE_BUNDLE1_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_RX_CTLE_BUNDLE1_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 15,
        step        = 1,
        default     = 0,
      endnumeric;

      numeric varid = SA_SETUP.DmiGen3RxCtlePeaking[OFFSET_2],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_RX_CTLE_BUNDLE2_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_RX_CTLE_BUNDLE2_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 15,
        step        = 1,
        default     = 0,
      endnumeric;
      numeric varid = SA_SETUP.DmiGen3RxCtlePeaking[OFFSET_3],
        prompt      = STRING_TOKEN(STR_DMI_GEN3_RX_CTLE_BUNDLE3_PROMPT),
        help        = STRING_TOKEN(STR_GEN3_RX_CTLE_BUNDLE3_HELP),
        flags       = RESET_REQUIRED,
        minimum     = 0,
        maximum     = 15,
        step        = 1,
        default     = 0,
      endnumeric;
    endform;

//--------------------------------
//--------------------------------

    form formid = AUTO_ID(IGFX_LCD_FORM_ID),
    title     = STRING_TOKEN(STR_IGFX_LCD);

      SUBTITLE(STRING_TOKEN(STR_IGFX_LCD))
      SEPARATOR

      oneof varid    = SA_SETUP.IgdBootType,
        prompt   = STRING_TOKEN(STR_VIDEO_BT_PROMPT),
        help     = STRING_TOKEN(STR_VIDEO_BT_HELP),
        option text = STRING_TOKEN(STR_VIDEO_BT_DEFAULT),      value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
        option text = STRING_TOKEN(STR_VIDEO_BT_EFP),          value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_VIDEO_BT_LFP),          value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_VIDEO_BT_EFP3),         value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_VIDEO_BT_EFP2),         value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_VIDEO_BT_EFP4),         value = 0x10, flags = RESET_REQUIRED;
      endoneof;

    suppressif ideqval SA_SETUP.IgdBootType == 0x0;
      oneof varid    = SA_SETUP.DisplayPipeB,
        prompt   = STRING_TOKEN(STR_VIDEO_BT_PIPE_B_PROMPT),
        help     = STRING_TOKEN(STR_VIDEO_BT_PIPE_B_HELP),
        option text = STRING_TOKEN(STR_VIDEO_BT_PIPE_B_DISABLED),       value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
        option text = STRING_TOKEN(STR_VIDEO_BT_EFP),          value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_VIDEO_BT_EFP3),         value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_VIDEO_BT_EFP2),         value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_VIDEO_BT_EFP4),         value = 0x10, flags = RESET_REQUIRED;
      endoneof;
    endif;

      oneof varid     = SA_SETUP.LcdPanelType,
        prompt      = STRING_TOKEN(STR_PANELTYPE_PROMPT),
        help        = STRING_TOKEN(STR_PANELTYPE_HELP),
        option text = STRING_TOKEN(STR_VIDEO_BT_DEFAULT),  value = 0, flags = RESET_REQUIRED | DEFAULT | MANUFACTURING;
        option text = STRING_TOKEN(STR_PANELTYPE_01), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_02), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_03), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_04), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_05), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_06), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_07), value = 7, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_08), value = 8, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_09), value = 9, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_10), value = 10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_13), value = 13, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_14), value = 14, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_15), value = 15, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_16), value = 16, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELTYPE_17), value = 17, flags = RESET_REQUIRED;
      endoneof;

      oneof varid     = SA_SETUP.LcdPanelScaling,
        prompt      = STRING_TOKEN(STR_PANELSCALING_PROMPT),
        help        = STRING_TOKEN(STR_PANELSCALING_HELP),
        option text = STRING_TOKEN(STR_PANELSCALING_AUTO), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELSCALING_OFF), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PANELSCALING_FORCE), value = 6, flags = RESET_REQUIRED;
      endoneof;

      oneof varid    = SA_SETUP.IgdLcdBlc,
        prompt   = STRING_TOKEN(STR_VIDEO_LCD_BLC),
        help     = STRING_TOKEN(STR_VIDEO_LCD_BLCHELP),
        option text = STRING_TOKEN(STR_VIDEO_LCD_BLC1), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_VIDEO_LCD_BLC2), value = 0x02, flags =  DEFAULT | MANUFACTURING |RESET_REQUIRED;
      endoneof;

     oneof varid  = SA_SETUP.ActiveLFP,
        prompt   = STRING_TOKEN (STR_ACTIVE_LFP),
        help     = STRING_TOKEN (STR_ACTIVE_LFP_HELP),
        option text = STRING_TOKEN (STR_NO_EDP_STRING), value = 0, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN (STR_EDPA_LFP_STRING), value = 3, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
     endoneof;

     oneof varid  = SA_SETUP.LfpColorDepth,
        prompt   = STRING_TOKEN (STR_LFP_COLOR_DEPTH),
        help     = STRING_TOKEN (STR_LFP_COLOR_DEPTH_HELP),
        option text = STRING_TOKEN (STR_18BIT_COLOR_DEPTH_STRING), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
        option text = STRING_TOKEN (STR_24BIT_COLOR_DEPTH_STRING), value = 1, flags =  RESET_REQUIRED;
     endoneof;

      numeric varid = SA_SETUP.VbiosBrightness,
        prompt      = STRING_TOKEN (STR_VBIOS_BACKLIGHT),
        help        = STRING_TOKEN (STR_VBIOS_BACKLIGHT_HELP),
        minimum     = 0,
        maximum     = 255,
        step        = 0,
        default     = 255,
      endnumeric;

    endform;

    form formid = AUTO_ID(IGFX_IUER_FORM_ID),
    title     = STRING_TOKEN(STR_IUER_SUPPORT_STRING);

      SUBTITLE(STRING_TOKEN(STR_IUER_SUPPORT_STRING))
      SEPARATOR

    oneof varid = SA_SETUP.IuerConvertibleEnable,
      prompt   = STRING_TOKEN(STR_IUER_SLATE_ENABLE),
      help     = STRING_TOKEN(STR_IUER_SLATE_ENABLE_HELP),
      default  = 0, defaultstore = MyStandardDefault,
      option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED_STRING), value = 1, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval SA_SETUP.IuerConvertibleEnable == 0;
      oneof varid = SA_SETUP.SlateIndicatorRT,
        prompt   = STRING_TOKEN(STR_SLATE_INDICATOR_RT),
        help     = STRING_TOKEN(STR_SLATE_INDICATOR_RT_HELP),
        option text = STRING_TOKEN(STR_SLATE_STRING), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_LAPTOP_STRING), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid = SA_SETUP.SlateIndicatorSx,
        prompt   = STRING_TOKEN(STR_SLATE_INDICATOR_SX),
        help     = STRING_TOKEN(STR_SLATE_INDICATOR_SX_HELP),
        option text = STRING_TOKEN(STR_SAME_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_TOGGLE_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    oneof varid = SA_SETUP.IuerDockEnable,
      prompt   = STRING_TOKEN(STR_IUER_DOCK_ENABLE),
      help     = STRING_TOKEN(STR_IUER_DOCK_ENABLE_HELP),
      default  = 0, defaultstore = MyStandardDefault,
      option text = STRING_TOKEN(STR_DISABLED_STRING), value = 0, flags = RESET_REQUIRED;
      option text = STRING_TOKEN(STR_ENABLED_STRING), value = 1, flags = RESET_REQUIRED;
    endoneof;

    suppressif ideqval SA_SETUP.IuerDockEnable == 0;
      oneof varid = SA_SETUP.DockIndicatorRT,
        prompt   = STRING_TOKEN(STR_DOCK_INDICATOR_RT),
        help     = STRING_TOKEN(STR_DOCK_INDICATOR_RT_HELP),
        option text = STRING_TOKEN(STR_UNDOCK_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DOCK_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid = SA_SETUP.DockIndicatorSx,
        prompt   = STRING_TOKEN(STR_DOCK_INDICATOR_SX),
        help     = STRING_TOKEN(STR_DOCK_INDICATOR_SX_HELP),
        option text = STRING_TOKEN(STR_SAME_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_TOGGLE_STRING), value = 1, flags = RESET_REQUIRED;
      endoneof;
    endif;

    endform;

    form formid = AUTO_ID(GT_POWER_CONFIG_FORM_ID),
    title     = STRING_TOKEN(STR_GT_POWER_CONFIG_FORM_TITLE);

      SUBTITLE(STRING_TOKEN(STR_GT_POWER_CONFIG_FORM_TITLE))
      SEPARATOR

      grayoutif ideqval SA_SETUP.PmSupport == 0;
        grayoutif ideqval SETUP_DATA.TccMode == 1;
          oneof varid = SA_SETUP.EnableRenderStandby,
            questionid  = AUTO_ID(VIDEO_RS2_QUESTION_ID),
            prompt   = STRING_TOKEN(STR_VIDEO_RS2_PROMPT),
            help     = STRING_TOKEN(STR_VIDEO_RS2_HELP),
            default  = 1, defaultstore = MyStandardDefault,
            option text = STRING_TOKEN(STR_DISABLED), value =0, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
          endoneof;
        endif;
      endif;

      //
      // Maximum GT frequency in multiples of 50MHz
      //
      oneof varid   = SA_SETUP.GtFreqMax,
        prompt  = STRING_TOKEN(STR_GT_FREQ),
        help    = STRING_TOKEN(STR_GT_FREQ_HELP),
        option text = STRING_TOKEN(STR_GT_FREQ_DEFAULT), value= 0xFF, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_100M), value= 2, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_150M), value= 3, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_200M), value= 4, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_250M), value= 5, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_300M), value= 6, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_350M), value= 7, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_400M), value= 8, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_450M), value= 9, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_500M), value= 10, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_550M), value= 11, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_600M), value= 12, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_650M), value= 13, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_700M), value= 14, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_750M), value= 15, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_800M), value= 16, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_850M), value= 17, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_900M), value= 18, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_950M), value= 19, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_1000M), value= 20, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_1050M), value= 21, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_1100M), value= 22, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_1150M), value= 23, flags=RESET_REQUIRED;
        option text = STRING_TOKEN(STR_GT_FREQ_1200M), value= 24, flags=RESET_REQUIRED;
      endoneof;

      grayoutif NOT ideqval SA_SETUP.GtFreqMax == 0xFF;
        oneof   varid   = SA_SETUP.DisableTurboGt,
          prompt  = STRING_TOKEN(STR_DISABLE_TURBO_GT),
          help    = STRING_TOKEN(STR_DISABLE_TURBO_GT_HELP),
          option text = STRING_TOKEN (STR_ENABLED_STRING), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        endoneof;
      endif;

    endform;

    form formid = AUTO_ID(MEM_TRAINING_FORM_ID),
    title = STRING_TOKEN(STR_MEMORY_TRAINING_ALGOS_PROMPT);

      oneof varid   = SA_SETUP.ECT,
        prompt      = STRING_TOKEN(STR_EARLY_CMD_TRNG_NAME),
        help        = STRING_TOKEN(STR_EARLY_CMD_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.SOT,
        prompt      = STRING_TOKEN(STR_SENSEAMP_TRNG_NAME),
        help        = STRING_TOKEN(STR_SENSEAMP_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.ERDMPRTC2D,
        prompt      = STRING_TOKEN(STR_ERDMPRTC2D_TRNG_NAME),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RDMPRT,
        prompt      = STRING_TOKEN(STR_RDMPR_TRNG_NAME),
        help        = STRING_TOKEN(STR_RDMPR_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RCVET,
        prompt      = STRING_TOKEN(STR_RCVEN_TRNG_NAME),
        help        = STRING_TOKEN(STR_RCVEN_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.JWRL,
        prompt      = STRING_TOKEN(STR_JWRL_TRNG_NAME),
        help        = STRING_TOKEN(STR_JWRL_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.Lp4DqsOscEn,
        prompt      = STRING_TOKEN(STR_LP4DQSOSCEN_NAME),
        help        = STRING_TOKEN(STR_LP4DQSOSCEN_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.EWRTC2D,
        prompt      = STRING_TOKEN(STR_EWRTC2D_TRNG_NAME),
        help        = STRING_TOKEN(STR_EWRTC2D_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.ERDTC2D,
        prompt      = STRING_TOKEN(STR_ERDTC2D_TRNG_NAME),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.WRTC1D,
        prompt      = STRING_TOKEN(STR_WRTC1D_TRNG_NAME),
        help        = STRING_TOKEN(STR_WRTC1D_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.WRVC1D,
        prompt      = STRING_TOKEN(STR_WRVC1D_TRNG_NAME),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RDTC1D,
        prompt      = STRING_TOKEN(STR_RDTC1D_TRNG_NAME),
        help        = STRING_TOKEN(STR_RDTC1D_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.DIMMODTT,
        prompt      = STRING_TOKEN(STR_DIMMODTT_TRNG_NAME),
        help        = STRING_TOKEN(STR_DIMMODTT_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      grayoutif ideqval SA_SETUP.DIMMODTT == 0;
        oneof varid    = SA_SETUP.MaxRttWr,
          prompt   = STRING_TOKEN(STR_MAX_RTT_WR_PROMPT),
          help     = STRING_TOKEN(STR_MAX_RTT_WR_HELP),
          option text = STRING_TOKEN (STR_ODT_OFF_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_120_OHMS_STRING), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      oneof varid   = SA_SETUP.DIMMRONT,
        prompt      = STRING_TOKEN(STR_DIMMRONT_TRNG_NAME),
        help        = STRING_TOKEN(STR_DIMMRONT_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.WRDSEQT,
        prompt      = STRING_TOKEN(STR_WRDSEQT_TRNG_NAME),
        help        = STRING_TOKEN(STR_EMPTY_STRING),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.WRSRT,
        prompt      = STRING_TOKEN(STR_WRSRT_TRNG_NAME),
        help        = STRING_TOKEN(STR_WRSRT_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RDODTT,
        prompt      = STRING_TOKEN(STR_RDODTT_TRNG_NAME),
        help        = STRING_TOKEN(STR_RDODTT_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RDEQT,
        prompt      = STRING_TOKEN(STR_RDEQT_TRNG_NAME),
        help        = STRING_TOKEN(STR_RDEQT_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RDAPT,
        prompt      = STRING_TOKEN(STR_RDAPT_TRNG_NAME),
        help        = STRING_TOKEN(STR_RDAPT_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.WRTC2D,
        prompt      = STRING_TOKEN(STR_WRTC2D_TRNG_NAME),
        help        = STRING_TOKEN(STR_WRTC2D_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RDTC2D,
        prompt      = STRING_TOKEN(STR_RDTC2D_TRNG_NAME),
        help        = STRING_TOKEN(STR_RDTC2D_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.CMDVC,
        prompt      = STRING_TOKEN(STR_CMDVC_TRNG_NAME),
        help        = STRING_TOKEN(STR_CMDVC_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.WRVC2D,
        prompt      = STRING_TOKEN(STR_WRVC2D_TRNG_NAME),
        help        = STRING_TOKEN(STR_WRVC2D_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RDVC2D,
        prompt      = STRING_TOKEN(STR_RDVC2D_TRNG_NAME),
        help        = STRING_TOKEN(STR_RDVC2D_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.LCT,
        prompt      = STRING_TOKEN(STR_LCT_TRNG_NAME),
        help        = STRING_TOKEN(STR_LCT_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RTL,
        prompt      = STRING_TOKEN(STR_RTL_TRNG_NAME),
        help        = STRING_TOKEN(STR_RTL_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.TAT,
        prompt      = STRING_TOKEN(STR_TAT_TRNG_NAME),
        help        = STRING_TOKEN(STR_TAT_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RMT,
        prompt      = STRING_TOKEN(STR_RMT_TRNG_NAME),
        help        = STRING_TOKEN(STR_RMT_TRNG_HELP),
        default     = 0, defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RMTBIT,
        prompt      = STRING_TOKEN(STR_RMTBIT_TRNG_NAME),
        help        = STRING_TOKEN(STR_RMTBIT_TRNG_HELP),
        default     = 0, defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.MarginLimitCheck,
        prompt      = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_NAME),
        help        = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_HELP),
        #if FixedPcdGet8(PcdEmbeddedEnable) == 0x1
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_L1),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_L2),  value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_BOTH),  value = 3, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        #else
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_L1),  value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_L2),  value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_BOTH),  value = 3, flags = RESET_REQUIRED;
        #endif
      endoneof;

      grayoutif (ideqval SA_SETUP.MarginLimitCheck == 0 OR ideqval SA_SETUP.MarginLimitCheck == 1);
        numeric varid   = SA_SETUP.MarginLimitL2,
          prompt      = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_L2_THSD_NAME),
          help        = STRING_TOKEN(STR_MARGIN_LIMIT_CHECK_L2_THSD_HELP),
          flags       = RESET_REQUIRED,
          minimum     = 1,
          maximum     = 300,
          step        = 1,
          default     = 200,
        endnumeric;
      endif;

      oneof varid   = SA_SETUP.MEMTST,
        prompt      = STRING_TOKEN(STR_MEMTST_TRNG_NAME),
        help        = STRING_TOKEN(STR_MEMTST_TRNG_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;


      oneof varid   = SA_SETUP.ALIASCHK,
        prompt      = STRING_TOKEN(STR_ALIASCHK_NAME),
        help        = STRING_TOKEN(STR_ALIASCHK_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RCVENC1D,
        prompt      = STRING_TOKEN(STR_RCVENC1D_NAME),
        help        = STRING_TOKEN(STR_RCVENC1D_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RMC,
        prompt      = STRING_TOKEN(STR_RMC_NAME),
        help        = STRING_TOKEN(STR_RMC_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.WRDSUDT,
        prompt      = STRING_TOKEN(STR_WRDSUDT_NAME),
        help        = STRING_TOKEN(STR_WRDSUDT_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.CMDSR,
        prompt      = STRING_TOKEN(STR_CMDSR_TRNG_NAME),
        help        = STRING_TOKEN(STR_CMDSR_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.CMDDSEQ,
        prompt      = STRING_TOKEN(STR_CMDDSEQ_TRNG_NAME),
        help        = STRING_TOKEN(STR_CMDDSEQ_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.CMDNORM,
        prompt      = STRING_TOKEN(STR_CMDNORM_TRNG_NAME),
        help        = STRING_TOKEN(STR_CMDNORM_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.EWRDSEQ,
        prompt      = STRING_TOKEN(STR_EWRDSEQ_TRNG_NAME),
        help        = STRING_TOKEN(STR_EWRDSEQ_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.RDVC1D,
        prompt      = STRING_TOKEN(STR_RDVC1D_TRNG_NAME),
        help        = STRING_TOKEN(STR_RDVC1D_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.TXTCO,
        prompt      = STRING_TOKEN(STR_TXTCO_TRNG_NAME),
        help        = STRING_TOKEN(STR_TXTCO_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.CLKTCO,
        prompt      = STRING_TOKEN(STR_CLKTCO_TRNG_NAME),
        help        = STRING_TOKEN(STR_CLKTCO_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.DIMMODTCA,
        prompt      = STRING_TOKEN(STR_DIMMODTCA_TRNG_NAME),
        help        = STRING_TOKEN(STR_DIMMODTCA_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.TXTCODQS,
        prompt      = STRING_TOKEN(STR_TXTCODQS_TRNG_NAME),
        help        = STRING_TOKEN(STR_TXTCODQS_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.DCC,
        prompt      = STRING_TOKEN(STR_DCC_TRNG_NAME),
        help        = STRING_TOKEN(STR_DCC_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.DQDFE,
        prompt      = STRING_TOKEN(STR_DQDFE_TRNG_NAME),
        help        = STRING_TOKEN(STR_DQDFE_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.SOTC,
        prompt      = STRING_TOKEN(STR_SOTC_TRNG_NAME),
        help        = STRING_TOKEN(STR_SOTC_TRNG_NAME),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

    endform;


    form formid = AUTO_ID(MEMORY_THERMAL_CONFIG_FORM_ID),
    title = STRING_TOKEN(STR_MEMORY_THERMAL_CONFIGURATION);

      SUBTITLE(STRING_TOKEN(STR_MEMORY_THERMAL_CONFIGURATION))
      SEPARATOR

      goto MEM_THERMMGT_FORM_ID,
        prompt  = STRING_TOKEN(STR_MEM_THERMMGT_TITLE),
        help    = STRING_TOKEN(STR_MEM_THERMMGT_HELP);

      oneof varid    = SA_SETUP.MemoryThermalManagement,
        prompt      = STRING_TOKEN(STR_MEMORY_THERMAL_MANAGEMENT_PROMPT),
        help        = STRING_TOKEN(STR_MEMORY_THERMAL_MANAGEMENT_HELP),
        option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT |MANUFACTURING |  RESET_REQUIRED;
      endoneof;

      suppressif ideqval SA_SETUP.MemoryThermalManagement == 0x0;
        oneof varid    = SA_SETUP.PeciInjectedTemp,
          prompt      = STRING_TOKEN(STR_PECI_INJECTED_TEMPERATURE_PROMPT),
          help        = STRING_TOKEN(STR_PECI_INJECTED_TEMPERATURE_HELP),
          option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
        endoneof;

        oneof varid    = SA_SETUP.ExttsViaTsOnBoard,
          prompt      = STRING_TOKEN(STR_EXTTS_OVER_TS_ON_BOARD_PROMPT),
          help        = STRING_TOKEN(STR_EXTTS_OVER_TS_ON_BOARD_HELP),
          option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
        endoneof;

        oneof varid    = SA_SETUP.ExttsViaTsOnDimm,
          prompt      = STRING_TOKEN(STR_EXTTS_OVER_TS_ON_DIMM_PROMPT),
          help        = STRING_TOKEN(STR_EXTTS_OVER_TS_ON_DIMM_HELP),
          option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
        endoneof;

        oneof varid    = SA_SETUP.VirtualTempSensor,
          prompt      = STRING_TOKEN(STR_VIRTUAL_TEMP_SENSOR_PROMPT),
          help        = STRING_TOKEN(STR_VIRTUAL_TEMP_SENSOR_HELP),
          option text = STRING_TOKEN(STR_DISABLED),  value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

    endform;

    form formid = AUTO_ID(MEM_THERMMGT_FORM_ID),
    title       = STRING_TOKEN(STR_MEM_THERMMGT_TITLE);

      SUBTITLE(STRING_TOKEN(STR_MEM_THERMMGT_TITLE))
      SEPARATOR

      oneof varid   = SA_SETUP.EnablePwrDn,
        prompt   = STRING_TOKEN (STR_PWRDN_PROMPT),
        help     = STRING_TOKEN (STR_PWRDN_HELP),
        option text = STRING_TOKEN(STR_PWRDN_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PWRDN_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.EnablePwrDnLpddr,
        prompt   = STRING_TOKEN (STR_PWRDN_LPDDR_PROMPT),
        help     = STRING_TOKEN (STR_PWRDN_LPDDR_HELP),
        option text = STRING_TOKEN(STR_PWRDN_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_PWRDN_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.Refresh2X,
        prompt   = STRING_TOKEN (STR_REFRESH_2X_MODE_PROMPT),
        help     = STRING_TOKEN (STR_REFRESH_2X_MODE_HELP),
        option text = STRING_TOKEN(STR_DISABLED),            value = 0x00, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_REFRESH_2X_WARM_HOT), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_REFRESH_2X_HOT),      value = 0x02, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.SrefCfgEna,
        prompt      = STRING_TOKEN(STR_SREFCFGENA_PROMPT),
        help        = STRING_TOKEN(STR_SREFCFGENA_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      numeric varid = SA_SETUP.SrefCfgIdleTmr,
        prompt  = STRING_TOKEN (STR_SREFCFGIDLETMR_PROMPT),
        help    = STRING_TOKEN (STR_SREFCFGIDLETMR_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 512,
        maximum = 65535,
        step    = 1,
        default = 512,
      endnumeric;

      oneof varid   = SA_SETUP.ThrtCkeMinDefeat,
        prompt      = STRING_TOKEN(STR_THRTCKEMINDEFEAT_PROMPT),
        help        = STRING_TOKEN(STR_THRTCKEMINDEFEAT_HELP),
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      numeric varid = SA_SETUP.ThrtCkeMinTmr,
        prompt  = STRING_TOKEN (STR_THRTCKEMINTMR_PROMPT),
        help    = STRING_TOKEN (STR_THRTCKEMINTMR_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0x0,
        maximum = 0xFF,
        step    = 1,
        default = 48,
      endnumeric;

      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformType == TypeUltUlx;
        oneof varid   = SA_SETUP.ThrtCkeMinDefeatLpddr,
          prompt      = STRING_TOKEN(STR_THRTCKEMINDEFEAT_LPDDR_PROMPT),
          help        = STRING_TOKEN(STR_THRTCKEMINDEFEAT_LPDDR_HELP),
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        endoneof;

        numeric varid = SA_SETUP.ThrtCkeMinTmrLpddr,
          prompt  = STRING_TOKEN (STR_THRTCKEMINTMR_LPDDR_PROMPT),
          help    = STRING_TOKEN (STR_THRTCKEMINTMR_LPDDR_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0x0,
          maximum = 0xFF,
          step    = 1,
          default = 64,
        endnumeric;
      endif;

      oneof varid   = SA_SETUP.DdrThermalSensor,
        prompt   = STRING_TOKEN (STR_LPDDR_THERMAL_SENSOR_PROMPT),
        help     = STRING_TOKEN (STR_LPDDR_THERMAL_SENSOR_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
      endoneof;

      goto DRAM_POWER_METER_FORM_ID,
        prompt  = STRING_TOKEN(STR_DRAM_POWER_METER_TITLE),
        help    = STRING_TOKEN(STR_MEM_THERMMGT_HELP);

      goto MEMORY_THERMAL_REPORTING_FORM_ID,
        prompt  = STRING_TOKEN(STR_MEMORY_THERMAL_REPORTING_TITLE),
        help    = STRING_TOKEN(STR_MEM_THERMMGT_HELP);

      goto MEMORY_RAPL_FORM_ID,
        prompt  = STRING_TOKEN(STR_MEMORY_RAPL_TITLE),
        help    = STRING_TOKEN(STR_MEM_THERMMGT_HELP);

    endform;

    form formid = AUTO_ID(DRAM_POWER_METER_FORM_ID),
    title       = STRING_TOKEN(STR_DRAM_POWER_METER_TITLE);

      SUBTITLE(STRING_TOKEN(STR_DRAM_POWER_METER_TITLE))
      SEPARATOR

      oneof varid  = SA_SETUP.UserPowerWeightsEn,
        prompt   = STRING_TOKEN (STR_PWR_WEIGHT_PROMPT),
        help     = STRING_TOKEN (STR_PWR_WEIGHT_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      grayoutif (ideqval SA_SETUP.UserPowerWeightsEn == 0);
        numeric varid = SA_SETUP.EnergyScaleFact,
          prompt  = STRING_TOKEN (STR_ENERGYSCALEFACT_PROMPT),
          help    = STRING_TOKEN (STR_ENERGYSCALEFACT_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 7,
          step    = 1,
          default = 4,
        endnumeric;

      SEPARATOR

        numeric varid = SA_SETUP.IdleEnergyCh0Dimm0,
          prompt  = STRING_TOKEN (STR_IDLEENERGYCH0DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_IDLEENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 63,
          step    = 1,
          default = 10,
        endnumeric;

        numeric varid = SA_SETUP.PdEnergyCh0Dimm0,
          prompt  = STRING_TOKEN (STR_PDENERGYCH0DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_PDENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 63,
          step    = 1,
          default = 6,
        endnumeric;

        numeric varid = SA_SETUP.ActEnergyCh0Dimm0,
          prompt  = STRING_TOKEN (STR_ACTENERGYCH0DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_ACTENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 172,
        endnumeric;

        numeric varid = SA_SETUP.RdEnergyCh0Dimm0,
          prompt  = STRING_TOKEN (STR_RDENERGYCH0DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_RDENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 212,
        endnumeric;

        numeric varid = SA_SETUP.WrEnergyCh0Dimm0,
          prompt  = STRING_TOKEN (STR_WRENERGYCH0DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_WRENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 221,
        endnumeric;

      SEPARATOR

        numeric varid = SA_SETUP.IdleEnergyCh0Dimm1,
          prompt  = STRING_TOKEN (STR_IDLEENERGYCH0DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_IDLEENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 63,
          step    = 1,
          default = 10,
        endnumeric;

        numeric varid = SA_SETUP.PdEnergyCh0Dimm1,
          prompt  = STRING_TOKEN (STR_PDENERGYCH0DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_PDENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 63,
          step    = 1,
          default = 6,
        endnumeric;

        numeric varid = SA_SETUP.ActEnergyCh0Dimm1,
          prompt  = STRING_TOKEN (STR_ACTENERGYCH0DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_ACTENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 172,
        endnumeric;

        numeric varid = SA_SETUP.RdEnergyCh0Dimm1,
          prompt  = STRING_TOKEN (STR_RDENERGYCH0DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_RDENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 212,
        endnumeric;

        numeric varid = SA_SETUP.WrEnergyCh0Dimm1,
          prompt  = STRING_TOKEN (STR_WRENERGYCH0DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_WRENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 221,
        endnumeric;

      SEPARATOR

        numeric varid = SA_SETUP.IdleEnergyCh1Dimm0,
          prompt  = STRING_TOKEN (STR_IDLEENERGYCH1DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_IDLEENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 63,
          step    = 1,
          default = 10,
        endnumeric;

        numeric varid = SA_SETUP.PdEnergyCh1Dimm0,
          prompt  = STRING_TOKEN (STR_PDENERGYCH1DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_PDENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 63,
          step    = 1,
          default = 6,
        endnumeric;

        numeric varid = SA_SETUP.ActEnergyCh1Dimm0,
          prompt  = STRING_TOKEN (STR_ACTENERGYCH1DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_ACTENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 172,
        endnumeric;

        numeric varid = SA_SETUP.RdEnergyCh1Dimm0,
          prompt  = STRING_TOKEN (STR_RDENERGYCH1DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_RDENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 212,
        endnumeric;

        numeric varid = SA_SETUP.WrEnergyCh1Dimm0,
          prompt  = STRING_TOKEN (STR_WRENERGYCH1DIMM0_PROMPT),
          help    = STRING_TOKEN (STR_WRENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 221,
        endnumeric;

      SEPARATOR

        numeric varid = SA_SETUP.IdleEnergyCh1Dimm1,
          prompt  = STRING_TOKEN (STR_IDLEENERGYCH1DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_IDLEENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 63,
          step    = 1,
          default = 10,
        endnumeric;

        numeric varid = SA_SETUP.PdEnergyCh1Dimm1,
          prompt  = STRING_TOKEN (STR_PDENERGYCH1DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_PDENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 63,
          step    = 1,
          default = 6,
        endnumeric;

        numeric varid = SA_SETUP.ActEnergyCh1Dimm1,
          prompt  = STRING_TOKEN (STR_ACTENERGYCH1DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_ACTENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 172,
        endnumeric;

        numeric varid = SA_SETUP.RdEnergyCh1Dimm1,
          prompt  = STRING_TOKEN (STR_RDENERGYCH1DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_RDENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 212,
        endnumeric;

        numeric varid = SA_SETUP.WrEnergyCh1Dimm1,
          prompt  = STRING_TOKEN (STR_WRENERGYCH1DIMM1_PROMPT),
          help    = STRING_TOKEN (STR_WRENERGY_CH_DIMM_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 221,
        endnumeric;

      endif;

    endform;

    form formid = AUTO_ID(MEMORY_THERMAL_REPORTING_FORM_ID),
    title       = STRING_TOKEN(STR_MEMORY_THERMAL_REPORTING_TITLE);

      oneof varid   = SA_SETUP.LockPTMregs,
        prompt   = STRING_TOKEN (STR_PDWN_CONFIG_CTL_PROMPT),
        help     = STRING_TOKEN (STR_PDWN_CONFIG_CTL_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
      endoneof;

      SEPARATOR
      SUBTITLE(STRING_TOKEN(STR_MEMORY_THERMAL_REPORTING_TITLE))
      SEPARATOR

      oneof varid   = SA_SETUP.EnableExtts,
        prompt   = STRING_TOKEN (STR_EXTTS_PROMPT),
        help     = STRING_TOKEN (STR_EXTTS_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.EnableCltm,
        prompt   = STRING_TOKEN (STR_CLTM_PROMPT),
        help     = STRING_TOKEN (STR_CLTM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      oneof varid   = SA_SETUP.EnableOltm,
        prompt   = STRING_TOKEN (STR_OLTM_PROMPT),
        help     = STRING_TOKEN (STR_OLTM_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING |RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;
      SEPARATOR
      SUBTITLE(STRING_TOKEN(STR_THERMAL_THRESHOLD))
      SEPARATOR

#if FixedPcdGetBool(PcdUpServerEnable) == 1
      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;
        oneof varid  = SA_SETUP.UserThresholdEnable,
          prompt   = STRING_TOKEN (STR_THRESHOLD_MANUAL_PROMPT),
          help     = STRING_TOKEN (STR_THRESHOLD_MANUAL_HELP),
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

    grayoutif (ideqval SA_SETUP.UserThresholdEnable == 0 AND ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer) ;
#endif

     numeric varid = SA_SETUP.WarmThresholdCh0Dimm0,
        prompt  = STRING_TOKEN (STR_WARMTHRCH0DIMM0_PROMPT),
        help    = STRING_TOKEN (STR_WARMTHR_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.WarmThresholdCh0Dimm1,
        prompt  = STRING_TOKEN (STR_WARMTHRCH0DIMM1_PROMPT),
        help    = STRING_TOKEN (STR_WARMTHR_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.HotThresholdCh0Dimm0,
        prompt  = STRING_TOKEN (STR_HOTTHRCH0DIMM0_PROMPT),
        help    = STRING_TOKEN (STR_HOTTHR_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.HotThresholdCh0Dimm1,
        prompt  = STRING_TOKEN (STR_HOTTHRCH0DIMM1_PROMPT),
        help    = STRING_TOKEN (STR_HOTTHR_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.WarmThresholdCh1Dimm0,
        prompt  = STRING_TOKEN (STR_WARMTHRCH1DIMM0_PROMPT),
        help    = STRING_TOKEN (STR_WARMTHR_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.WarmThresholdCh1Dimm1,
        prompt  = STRING_TOKEN (STR_WARMTHRCH1DIMM1_PROMPT),
        help    = STRING_TOKEN (STR_WARMTHR_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.HotThresholdCh1Dimm0,
        prompt  = STRING_TOKEN (STR_HOTTHRCH1DIMM0_PROMPT),
        help    = STRING_TOKEN (STR_HOTTHR_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.HotThresholdCh1Dimm1,
        prompt  = STRING_TOKEN (STR_HOTTHRCH1DIMM1_PROMPT),
        help    = STRING_TOKEN (STR_HOTTHR_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

#if FixedPcdGetBool(PcdUpServerEnable) == 1
    endif;
#endif
      SEPARATOR
      SUBTITLE(STRING_TOKEN(STR_THERMAL_THROTTLE_BUDGET))
      SEPARATOR

#if FixedPcdGetBool(PcdUpServerEnable) == 1
      suppressif NOT ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer;
        oneof varid  = SA_SETUP.UserBudgetEnable,
          prompt   = STRING_TOKEN (STR_BUDGET_MANUAL_PROMPT),
          help     = STRING_TOKEN (STR_BUDGET_MANUAL_HELP),
          option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

    grayoutif (ideqval SA_SETUP.UserBudgetEnable == 0 AND ideqval SETUP_VOLATILE_DATA.PlatformFlavor == FlavorUpServer);
#endif
      numeric varid = SA_SETUP.WarmBudgetCh0Dimm0,
        prompt  = STRING_TOKEN (STR_WARMBUDGETCH0DIMM0_PROMPT),
        help    = STRING_TOKEN (STR_WARMBUDGET_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.WarmBudgetCh0Dimm1,
        prompt  = STRING_TOKEN (STR_WARMBUDGETCH0DIMM1_PROMPT),
        help    = STRING_TOKEN (STR_WARMBUDGET_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.HotBudgetCh0Dimm0,
        prompt  = STRING_TOKEN (STR_HOTBUDGETCH0DIMM0_PROMPT),
        help    = STRING_TOKEN (STR_HOTBUDGET_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.HotBudgetCh0Dimm1,
        prompt  = STRING_TOKEN (STR_HOTBUDGETCH0DIMM1_PROMPT),
        help    = STRING_TOKEN (STR_HOTBUDGET_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.WarmBudgetCh1Dimm0,
        prompt  = STRING_TOKEN (STR_WARMBUDGETCH1DIMM0_PROMPT),
        help    = STRING_TOKEN (STR_WARMBUDGET_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.WarmBudgetCh1Dimm1,
        prompt  = STRING_TOKEN (STR_WARMBUDGETCH1DIMM1_PROMPT),
        help    = STRING_TOKEN (STR_WARMBUDGET_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.HotBudgetCh1Dimm0,
        prompt  = STRING_TOKEN (STR_HOTBUDGETCH1DIMM0_PROMPT),
        help    = STRING_TOKEN (STR_HOTBUDGET_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;

      numeric varid = SA_SETUP.HotBudgetCh1Dimm1,
        prompt  = STRING_TOKEN (STR_HOTBUDGETCH1DIMM1_PROMPT),
        help    = STRING_TOKEN (STR_HOTBUDGET_CH_DIMM_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 255,
        step    = 1,
        default = 255,
      endnumeric;
    endform;

    form formid = AUTO_ID(MEMORY_RAPL_FORM_ID),
    title       = STRING_TOKEN(STR_MEMORY_RAPL_TITLE);

      SUBTITLE(STRING_TOKEN(STR_MEMORY_RAPL_TITLE))
      SEPARATOR

      grayoutif (ideqval SA_SETUP.UserPowerWeightsEn == 0);
        numeric varid = SA_SETUP.RaplPwrFlCh0,
          prompt  = STRING_TOKEN (STR_RAPLPWRFLCH0_PROMPT),
          help    = STRING_TOKEN (STR_RAPLPWRFLCH0_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 0,
        endnumeric;

        numeric varid = SA_SETUP.RaplPwrFlCh1,
          prompt  = STRING_TOKEN (STR_RAPLPWRFLCH1_PROMPT),
          help    = STRING_TOKEN (STR_RAPLPWRFLCH1_HELP),
          flags   = 0 | RESET_REQUIRED,
          minimum = 0,
          maximum = 255,
          step    = 1,
          default = 0,
        endnumeric;
      endif;

      SEPARATOR

      oneof varid   = SA_SETUP.RaplLim2Lock,
        prompt      = STRING_TOKEN(STR_RAPLLIM2LOCK_PROMPT),
        help        = STRING_TOKEN(STR_RAPLLIM2LOCK_HELP),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
      endoneof;

      grayoutif ideqval SETUP_DATA.TccMode == 1;
        oneof varid   = SA_SETUP.RaplLim1Ena,
          questionid  = AUTO_ID(RAPLLIM1_ENABLE_QUESTION_ID),
          prompt      = STRING_TOKEN(STR_RAPLLIM1ENA_PROMPT),
          help        = STRING_TOKEN(STR_RAPLLIM1ENA_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      numeric varid = SA_SETUP.RaplLim1Pwr,
        prompt  = STRING_TOKEN (STR_RAPLLIM1PWR_PROMPT),
        help    = STRING_TOKEN (STR_RAPLLIM1PWR_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 16383,
        step    = 1,
        default value = 0,
      endnumeric;

      numeric varid = SA_SETUP.RaplLim1WindX,
        prompt  = STRING_TOKEN (STR_RAPLLIM1WINDX_PROMPT),
        help    = STRING_TOKEN (STR_RAPLLIM1WINDX_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 3,
        step    = 1,
        default value = 0,
      endnumeric;

      numeric varid = SA_SETUP.RaplLim1WindY,
        prompt  = STRING_TOKEN (STR_RAPLLIM1WINDY_PROMPT),
        help    = STRING_TOKEN (STR_RAPLLIM1WINDY_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 31,
        step    = 1,
        default value = 0,
      endnumeric;

      SEPARATOR

      grayoutif ideqval SETUP_DATA.TccMode == 1;
        oneof varid   = SA_SETUP.RaplLim2Ena,
          questionid  = AUTO_ID(RAPLLIM2_ENABLE_QUESTION_ID),
          prompt      = STRING_TOKEN(STR_RAPLLIM2ENA_PROMPT),
          help        = STRING_TOKEN(STR_RAPLLIM2ENA_HELP),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      numeric varid = SA_SETUP.RaplLim2Pwr,
        prompt  = STRING_TOKEN (STR_RAPLLIM2PWR_PROMPT),
        help    = STRING_TOKEN (STR_RAPLLIM2PWR_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 16383,
        step    = 1,
        default = 222,
      endnumeric;

      numeric varid = SA_SETUP.RaplLim2WindX,
        prompt  = STRING_TOKEN (STR_RAPLLIM2WINDX_PROMPT),
        help    = STRING_TOKEN (STR_RAPLLIM2WINDX_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 3,
        step    = 1,
        default = 1,
      endnumeric;

      numeric varid = SA_SETUP.RaplLim2WindY,
        prompt  = STRING_TOKEN (STR_RAPLLIM2WINDY_PROMPT),
        help    = STRING_TOKEN (STR_RAPLLIM2WINDY_HELP),
        flags   = 0 | RESET_REQUIRED,
        minimum = 0,
        maximum = 31,
        step    = 1,
        default = 10,
      endnumeric;
    endform;

#if FixedPcdGetBool(PcdUpServerEnable) == 1
    form formid = AUTO_ID(MEMORY_TSOD_FORM_ID),
    title       = STRING_TOKEN(STR_STSOD_TITLE);

      SUBTITLE(STRING_TOKEN(STR_STSOD_TITLE))
      SEPARATOR

      oneof varid  = SA_SETUP.TsodManualEnable,
        prompt   = STRING_TOKEN (STR_TEMP_TSOD_MANUAL_PROMPT),
        help     = STRING_TOKEN (STR_TEMP_TSOD_MANUAL_HELP),
        option text = STRING_TOKEN (STR_DISABLED_STRING), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN (STR_ENABLED_STRING),  value = 1, flags = RESET_REQUIRED;
      endoneof;

       grayoutif ideqval SA_SETUP.TsodManualEnable == 0;
        numeric varid  = SA_SETUP.TsodThigMax,
          prompt  = STRING_TOKEN (STR_CLTM_THIGH_PROMPT),
          help    = STRING_TOKEN (STR_CLTM_THIGH_PROMPT_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0,   // Minimum is 0MB
          maximum = 128, // Maximum is 1GB
          step    = 1,
          default = 93,
        endnumeric;

        numeric varid  = SA_SETUP.TsodTcritMax,
          prompt  = STRING_TOKEN (STR_CLTM_TCRITMAX_PROMPT),
          help    = STRING_TOKEN (STR_CLTM_TCRITMAX_PROMPT_HELP),
          flags   = RESET_REQUIRED,
          minimum = 0,   // Minimum is 0MB
          maximum = 128, // Maximum is 1GB
          step    = 1,
          default = 105,
        endnumeric;
       endif;

      checkbox varid = SA_SETUP.TsodEventMode,
       prompt = STRING_TOKEN(STR_EVENT_MODE_PROMPT),
       help   = STRING_TOKEN(STR_EVENT_MODE_HELP),
       flags  = CHECKBOX_DEFAULT | RESET_REQUIRED,
       key    = 0,
      endcheckbox;

      checkbox varid = SA_SETUP.TsodEventPolarity,
       prompt = STRING_TOKEN(STR_POLARITY_PROMPT),
       help   = STRING_TOKEN(STR_POLARITY_MODE_HELP),
       flags  = 0 | RESET_REQUIRED,
       key    = 0,
      endcheckbox;

      checkbox varid = SA_SETUP.TsodCriticalEventOnly,
       prompt = STRING_TOKEN(STR_CRITICAL_EVENT_ONLY_PROMPT),
       help   = STRING_TOKEN(STR_CRITICAL_EVENT_ONLY_HELP),
       flags  = CHECKBOX_DEFAULT | RESET_REQUIRED,
       key    = 0,
      endcheckbox;

      checkbox varid = SA_SETUP.TsodEventOutputControl,
       prompt = STRING_TOKEN(STR_EVENT_OUTPUT_CONTROL_PROMPT),
       help   = STRING_TOKEN(STR_EVENT_OUTPUT_CONTROL_HELP),
       flags  = CHECKBOX_DEFAULT | RESET_REQUIRED,
       key    = 0,
      endcheckbox;

      checkbox varid = SA_SETUP.TsodAlarmwindowLockBit,
       prompt = STRING_TOKEN(STR_ALARM_WINDOW_LOCK_PROMPT),
       help   = STRING_TOKEN(STR_ALARM_WINDOW_LOCK_HELP),
       flags  = 0 | RESET_REQUIRED,
       key    = 0,
      endcheckbox;

      checkbox varid = SA_SETUP.TsodCriticaltripLockBit,
       prompt = STRING_TOKEN(STR_CRITICAL_TRIP_LOCK_PROMPT),
       help   = STRING_TOKEN(STR_CRITICAL_TRIP_LOCK_HELP),
       flags  = 0 | RESET_REQUIRED,
       key    = 0,
      endcheckbox;

      checkbox varid = SA_SETUP.TsodShutdownMode,
       prompt = STRING_TOKEN(STR_SHUTDOWN_MODE_PROMPT),
       help   = STRING_TOKEN(STR_SHUTDOWN_MODE_HELP),
       flags  = 0 | RESET_REQUIRED,
       key    = 0,
      endcheckbox;
    endform;
#endif


    form formid = AUTO_ID(MIPICAM_OPTIONS_FORM_ID),
      title = STRING_TOKEN(STR_MIPICAM_OPTIONS_FORM_TITLE);
      oneof varid   = SETUP_DATA.MipiCam_ControlLogic0,
        prompt      = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0),
        help        = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0),
        default  = 0, defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0 == 0;
        goto 147,  // go to ControlLogic0 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          flags   = 0,
          key     = 0;
      endif;

      oneof varid   = SETUP_DATA.MipiCam_ControlLogic1,
        prompt      = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1),
        help        = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1 == 0;
        goto 148,  // go to ControlLogic1 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          flags   = 0,
          key     = 0;
      endif;

      oneof varid   = SETUP_DATA.MipiCam_ControlLogic2,
        prompt      = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC2),
        help        = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC2),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2 == 0;
        goto 149,  // go to ControlLogic2 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          flags   = 0,
          key     = 0;
      endif;

      oneof varid   = SETUP_DATA.MipiCam_ControlLogic3,
        prompt      = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC3),
        help        = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC3),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3 == 0;
        goto 150,  // go to ControlLogic3 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

      suppressif  NOT ideqval SETUP_DATA.MipiCam4Enable == 1;
        oneof varid   = SETUP_DATA.MipiCam_ControlLogic4,
          prompt      = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC4),
          help        = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC4),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4 == 0;
        goto 151,  // go to ControlLogic4 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

      suppressif NOT ideqval SETUP_DATA.MipiCam5Enable == 1;
        oneof varid   = SETUP_DATA.MipiCam_ControlLogic5,
          prompt      = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC5),
          help        = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC5),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5 == 0;
        goto 152,  // go to ControlLogic5 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

      oneof varid   = SETUP_DATA.MipiCam_Link0,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0),
        help        = STRING_TOKEN(STR_MIPICAM_LINK0),
        default     = 0, defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags = RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.MipiCam_Link0 == 0;
        goto 141,  // go to Link0 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

      oneof varid   = SETUP_DATA.MipiCam_Link1,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1),
        help        = STRING_TOKEN(STR_MIPICAM_LINK1),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.MipiCam_Link1 == 0;
        goto 142,   // go to Link1 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

      oneof varid   = SETUP_DATA.MipiCam_Link2,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2),
        help        = STRING_TOKEN(STR_MIPICAM_LINK2),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.MipiCam_Link2 == 0;
        goto 143,   // go to Link2 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

      oneof varid   = SETUP_DATA.MipiCam_Link3,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3),
        help        = STRING_TOKEN(STR_MIPICAM_LINK3),
        option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
      endoneof;

      suppressif ideqval SETUP_DATA.MipiCam_Link3 == 0;
        goto 144,   // go to Link3 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

      suppressif  NOT ideqval SETUP_DATA.MipiCam4Enable == 1;
        oneof varid   = SETUP_DATA.MipiCam_Link4,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK4),
          help        = STRING_TOKEN(STR_MIPICAM_LINK4),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_Link4 == 0;
        goto 145,   // go to Link4 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

      suppressif  NOT ideqval SETUP_DATA.MipiCam5Enable == 1;
        oneof varid   = SETUP_DATA.MipiCam_Link5,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK5),
          help        = STRING_TOKEN(STR_MIPICAM_LINK5),
          option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_ENABLED),  value = 1, flags =  RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_Link5 == 0;
        goto 146,   // go to Link5 menu
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          help     = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS),
          flags    = 0,
          key      = 0;
      endif;

    endform; // End of MIPICAM_OPTIONS_FORM_ID


    // *********************************************************
    form formid = 141,
      title    = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_LINK0);

      oneof varid   = SETUP_DATA.MipiCam_Link0_SensorModel,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SENSOR_MODEL),
        help        = STRING_TOKEN(STR_MIPICAM_SENSOR_MODEL),
        option text = STRING_TOKEN(STR_MIPICAM_IMX135), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5693), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX179), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8858), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9728), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX188), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX208), value = 7, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5670), value = 8, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8865), value = 9, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_HM2051), value = 10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2742), value = 11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9234), value = 12, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8856), value = 13, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV16860), value = 14, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX362), value = 15, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX488), value = 16, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_USER), value = 255, flags = RESET_REQUIRED;
      endoneof;

      // User defined _HID for Link0
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link0_SensorModel == 255;
         string varid = SETUP_DATA.MipiCam_Link0_UserHid,
          prompt   = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          help     = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          minsize  = 6,
          maxsize  = 8,
        endstring;
      endif;

      oneof varid     = SETUP_DATA.MipiCam_LanesClkDiv,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_LANES_CLK_DIV),
        help        = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_Link0_DriverData_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Control Logic
      oneof varid = SETUP_DATA.MipiCam_Link0_DriverData_ControlLogic,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_GPIO_CONTROL),
        help     = STRING_TOKEN(STR_MIPICAM_GPIO_CONTROL),
        default  = 0xFF, defaultstore = MyStandardDefault,
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = RESET_REQUIRED;
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC4), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC5), value = 3, flags = RESET_REQUIRED;
        endif
      endoneof;

      // Physical location
      oneof varid     = SETUP_DATA.MipiCam_Link0_CameraPhysicalLocation,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_LOCATION),
        help        = STRING_TOKEN(STR_MIPICAM_LOCATION),
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x61, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x69, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // Flash support
      oneof varid     = SETUP_DATA.MipiCam_Link0_DriverData_FlashSupport,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_FLASH_SUPPORT),
        help        = STRING_TOKEN(STR_MIPICAM_FLASH_SUPPORT),
        option text = STRING_TOKEN(STR_MIPICAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
      endoneof;

      // Privacy LED
      oneof varid   = SETUP_DATA.MipiCam_Link0_DriverData_PrivacyLed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_PRIVACY_LED),
        help        = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED),
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // Rotation
      oneof varid     = SETUP_DATA.MipiCam_Link0_DriverData_Degree,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_DEGREE),
        help        = STRING_TOKEN(STR_MIPICAM_DEGREE),
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
      endoneof;

      // PMIC Position
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link0_DriverData_CrdVersion == 0x50;
        oneof varid   = SETUP_DATA.MipiCam_Link0_DriverData_PmicPosition,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_PMIC_POSITION),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION),
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Voltage Rail
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link0_DriverData_PmicPosition == 1;
        oneof varid   = SETUP_DATA.MipiCam_Link0_DriverData_VoltageRail,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_VOLTAGE_RAIL),
          help        = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL),
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // PPR Value
      numeric varid = SETUP_DATA.MipiCam_Link0_DriverData_PprValue,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_PPR_VALUE),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_VALUE_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 255,
        step     = 1,
        default  = 16,
      endnumeric;

      // PPR Unit
      numeric varid = SETUP_DATA.MipiCam_Link0_DriverData_PprUnit,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_PPR_UNIT),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_UNIT_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 15,
        step     = 1,
        default  = 10,
      endnumeric;

      // Camera Module Name
      string varid    = SETUP_DATA.MipiCam_Link0_ModuleName,
        prompt   = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        help     = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        minsize  = 1,
        maxsize  = 15,
      endstring;

      // Lane Used
      oneof varid     = SETUP_DATA.MipiCam_Link0_DriverData_LaneUsed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_LANE_USED),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_LANE_USED),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X4), value = 4, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X8), value = 8, flags = RESET_REQUIRED;
      endoneof;

      // MCLK
      numeric varid     = SETUP_DATA.MipiCam_Link0_DriverData_Mclk,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_MCLK),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_MCLK),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 6000000,
        maximum  = 27000000,
        step     = 100000,
        default  = 19200000,
      endnumeric;

      // EEPROM Type
      oneof varid     = SETUP_DATA.MipiCam_Link0_DriverData_EepromType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_EEPROM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_M24C64), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_DW9806B), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C16), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C64), value = 0x11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA16), value = 0x12, flags = RESET_REQUIRED;
      endoneof;

      // VCM Type
      oneof varid     = SETUP_DATA.MipiCam_Link0_DriverData_VcmType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_VCM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_VCM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_NONE),        value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5823),      value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9714),      value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5816),      value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9719),      value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9718),      value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9806B),     value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_WV517S),      value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898122XA),  value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898212AXB), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED1),   value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED2),   value = 0x0B, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AK7371),      value = 0x0F, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_BU64297GWZ),  value = 0x10, flags = RESET_REQUIRED;
      endoneof;

      // I2C devices
      numeric varid     = SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_DEVICES_I2C),
        help        = STRING_TOKEN(STR_MIPICAM_DEVICES_I2C),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 12,
        step     = 1,
        default  = 6,
      endnumeric;

      suppressif ideqval SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0;
        // I2C channel
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C Device 0
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE0);

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS0),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x10,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE0),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif ;

      // I2C Device 1
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE1);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS1),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x0E,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE1),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 2
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE2);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS2),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x50,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE2),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 3
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE3);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS3),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x51,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE3),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 4
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3 4;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE4);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS4),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x52,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE4),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 5
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE5);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS5),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x53,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE5),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 6
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE6);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS6),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x54,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE6),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 7
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE7);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS7),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x55,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE7),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 8
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE8);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS8),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x56,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE8),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 9
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE9);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS9),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x57,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE9),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 10
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE10);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS10),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x58,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE10),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 11
      suppressif ideqvallist SETUP_DATA.MipiCam_Link0_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE11);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link0_I2cAddress[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_ADDRESS11),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x59,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link0_I2cDeviceType[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK0_I2C_DEVICE_TYPE11),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;
    endform;

    // *********************************************************
    form formid = 142,
      title    = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_LINK1);

      oneof varid   = SETUP_DATA.MipiCam_Link1_SensorModel,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_SENSOR_MODEL),
        help        = STRING_TOKEN(STR_MIPICAM_SENSOR_MODEL),
        option text = STRING_TOKEN(STR_MIPICAM_IMX135), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5693), value = 1, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX179), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8858), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9728), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX188), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX208), value = 7, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5670), value = 8, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8865), value = 9, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_HM2051), value = 10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2742), value = 11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9234), value = 12, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8856), value = 13, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV16860), value = 14, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX362), value = 15, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX488), value = 16, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_USER), value = 255, flags = RESET_REQUIRED;
      endoneof;

      // User defined _HID for Link1
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link1_SensorModel == 255;
         string varid = SETUP_DATA.MipiCam_Link1_UserHid,
          prompt   = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          help     = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          minsize  = 6,
          maxsize  = 8,
        endstring;
      endif;

      oneof varid     = SETUP_DATA.MipiCam_LanesClkDiv,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_LANES_CLK_DIV),
        help        = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_Link1_DriverData_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Control Logic
      oneof varid = SETUP_DATA.MipiCam_Link1_DriverData_ControlLogic,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_GPIO_CONTROL),
        help     = STRING_TOKEN(STR_MIPICAM_GPIO_CONTROL),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC4), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC5), value = 3, flags = RESET_REQUIRED;
        endif
      endoneof;

      // Physical location
      oneof varid     = SETUP_DATA.MipiCam_Link1_CameraPhysicalLocation,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_LOCATION),
        help        = STRING_TOKEN(STR_MIPICAM_LOCATION),
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x61, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x69, flags = RESET_REQUIRED;
      endoneof;

      // Flash support
      oneof varid     = SETUP_DATA.MipiCam_Link1_DriverData_FlashSupport,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_FLASH_SUPPORT),
        help        = STRING_TOKEN(STR_MIPICAM_FLASH_SUPPORT),
        option text = STRING_TOKEN(STR_MIPICAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
      endoneof;

      // Privacy LED
      oneof varid   = SETUP_DATA.MipiCam_Link1_DriverData_PrivacyLed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_PRIVACY_LED),
        help        = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED),
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // Rotation
      oneof varid     = SETUP_DATA.MipiCam_Link1_DriverData_Degree,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_DEGREE),
        help        = STRING_TOKEN(STR_MIPICAM_DEGREE),
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
      endoneof;

      // PMIC Position
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link1_DriverData_CrdVersion == 0x50;
        oneof varid   = SETUP_DATA.MipiCam_Link1_DriverData_PmicPosition,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_PMIC_POSITION),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION),
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Voltage Rail
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link1_DriverData_PmicPosition == 1;
        oneof varid   = SETUP_DATA.MipiCam_Link1_DriverData_VoltageRail,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_VOLTAGE_RAIL),
          help        = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL),
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;
      // PPR Value
      numeric varid = SETUP_DATA.MipiCam_Link1_DriverData_PprValue,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_PPR_VALUE),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_VALUE_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 255,
        step     = 1,
        default  = 16,
      endnumeric;

      // PPR Unit
      numeric varid = SETUP_DATA.MipiCam_Link1_DriverData_PprUnit,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_PPR_UNIT),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_UNIT_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 15,
        step     = 1,
        default  = 10,
      endnumeric;

      // Camera Module Name
      string varid    = SETUP_DATA.MipiCam_Link1_ModuleName,
        prompt   = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        help     = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        minsize  = 1,
        maxsize  = 15,
      endstring;

      // Lane Used
      oneof varid     = SETUP_DATA.MipiCam_Link1_DriverData_LaneUsed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_SDD_LANE_USED),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_LANE_USED),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X2), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X4), value = 4, flags = RESET_REQUIRED;
      endoneof;

      // MCLK
      numeric varid     = SETUP_DATA.MipiCam_Link1_DriverData_Mclk,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_MCLK),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_MCLK),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 6000000,
        maximum  = 27000000,
        step     = 100000,
        default  = 19200000,
      endnumeric;

      // EEPROM Type
      oneof varid     = SETUP_DATA.MipiCam_Link1_DriverData_EepromType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_SDD_EEPROM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_M24C64), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_DW9806B), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C16), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C64), value = 0x11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA16), value = 0x12, flags = RESET_REQUIRED;
      endoneof;

      // VCM Type
      oneof varid     = SETUP_DATA.MipiCam_Link1_DriverData_VcmType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_SDD_VCM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_VCM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_NONE),        value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5823),      value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9714),      value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5816),      value = 0x03, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9719),      value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9718),      value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9806B),     value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_WV517S),      value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898122XA),  value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898212AXB), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED1),   value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED2),   value = 0x0B, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AK7371),      value = 0x0F, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_BU64297GWZ),  value = 0x10, flags = RESET_REQUIRED;
      endoneof;


      // I2C devices
      numeric varid     = SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK1_DEVICES_I2C),
        help        = STRING_TOKEN(STR_MIPICAM_DEVICES_I2C),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 12,
        step     = 1,
        default  = 6,
      endnumeric;

      suppressif ideqval SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0;
        // I2C channel
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C Device 0
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE0);

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS0),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x10,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE0),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif ;

      // I2C Device 1
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE1);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS1),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x0C,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE1),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 2
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE2);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS2),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x50,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE2),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 3
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE3);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS3),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x51,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE3),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 4
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3 4;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE4);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS4),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x52,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE4),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 5
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE5);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS5),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x53,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE5),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 6
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE6);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS6),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x54,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE6),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 7
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE7);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS7),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x55,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE7),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 8
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE8);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS8),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x56,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE8),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 9
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE9);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS9),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x57,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE9),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 10
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE10);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS10),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x58,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE10),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 11
      suppressif ideqvallist SETUP_DATA.MipiCam_Link1_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE11);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link1_I2cAddress[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_ADDRESS11),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x59,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link1_I2cDeviceType[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK1_I2C_DEVICE_TYPE11),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;
    endform;

    // *********************************************************
    form formid = 143,
      title    = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_LINK2);

      oneof varid   = SETUP_DATA.MipiCam_Link2_SensorModel,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_SENSOR_MODEL),
        help        = STRING_TOKEN(STR_MIPICAM_SENSOR_MODEL),
        option text = STRING_TOKEN(STR_MIPICAM_IMX135), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5693), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX179), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8858), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9728), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX188), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX208), value = 7, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5670), value = 8, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8865), value = 9, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_HM2051), value = 10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2742), value = 11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9234), value = 12, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8856), value = 13, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV16860), value = 14, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX362), value = 15, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX488), value = 16, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_USER), value = 255, flags = RESET_REQUIRED;
      endoneof;

      // User defined _HID for Link2
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link2_SensorModel == 255;
         string varid = SETUP_DATA.MipiCam_Link2_UserHid,
          prompt   = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          help     = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          minsize  = 6,
          maxsize  = 8,
        endstring;
      endif;

      oneof varid     = SETUP_DATA.MipiCam_LanesClkDiv,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_LANES_CLK_DIV),
        help        = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_Link2_DriverData_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Control Logic
      oneof varid = SETUP_DATA.MipiCam_Link2_DriverData_ControlLogic,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_GPIO_CONTROL),
        help     = STRING_TOKEN(STR_MIPICAM_GPIO_CONTROL),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC4), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC5), value = 3, flags = RESET_REQUIRED;
        endif
      endoneof;

      // Physical location
      oneof varid     = SETUP_DATA.MipiCam_Link2_CameraPhysicalLocation,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_LOCATION),
        help        = STRING_TOKEN(STR_MIPICAM_LOCATION),
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x61, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x69, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // Flash support
      oneof varid     = SETUP_DATA.MipiCam_Link2_DriverData_FlashSupport,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_FLASH_SUPPORT),
        help        = STRING_TOKEN(STR_MIPICAM_FLASH_SUPPORT),
        option text = STRING_TOKEN(STR_MIPICAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
      endoneof;

      // Privacy LED
      oneof varid   = SETUP_DATA.MipiCam_Link2_DriverData_PrivacyLed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_PRIVACY_LED),
        help        = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED),
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // Rotation
      oneof varid     = SETUP_DATA.MipiCam_Link2_DriverData_Degree,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_DEGREE),
        help        = STRING_TOKEN(STR_MIPICAM_DEGREE),
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
      endoneof;

      // PMIC Position
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link2_DriverData_CrdVersion == 0x50;
        oneof varid   = SETUP_DATA.MipiCam_Link2_DriverData_PmicPosition,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_PMIC_POSITION),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION),
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Voltage Rail
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link2_DriverData_PmicPosition == 1;
        oneof varid   = SETUP_DATA.MipiCam_Link2_DriverData_VoltageRail,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_VOLTAGE_RAIL),
          help        = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL),
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // PPR Value
      numeric varid = SETUP_DATA.MipiCam_Link2_DriverData_PprValue,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_PPR_VALUE),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_VALUE_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 255,
        step     = 1,
        default  = 16,
      endnumeric;

      // PPR Unit
      numeric varid = SETUP_DATA.MipiCam_Link2_DriverData_PprUnit,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_PPR_UNIT),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_UNIT_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 15,
        step     = 1,
        default  = 10,
      endnumeric;

      // Camera Module Name
      string varid    = SETUP_DATA.MipiCam_Link2_ModuleName,
        prompt   = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        help     = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        minsize  = 1,
        maxsize  = 15,
      endstring;

      // Lane Used
      oneof varid     = SETUP_DATA.MipiCam_Link2_DriverData_LaneUsed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_SDD_LANE_USED),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_LANE_USED),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X4), value = 4, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // MCLK
      numeric varid     = SETUP_DATA.MipiCam_Link2_DriverData_Mclk,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_MCLK),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_MCLK),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 6000000,
        maximum  = 27000000,
        step     = 100000,
        default  = 19200000,
      endnumeric;

      // EEPROM Type
      oneof varid     = SETUP_DATA.MipiCam_Link2_DriverData_EepromType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_SDD_EEPROM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_M24C64), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_DW9806B), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C16), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C64), value = 0x11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA16), value = 0x12, flags = RESET_REQUIRED;
      endoneof;

      // VCM Type
      oneof varid     = SETUP_DATA.MipiCam_Link2_DriverData_VcmType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_SDD_VCM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_VCM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_NONE),        value = 0x00, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5823),      value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9714),      value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5816),      value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9719),      value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9718),      value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9806B),     value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_WV517S),      value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898122XA),  value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898212AXB), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED1),   value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED2),   value = 0x0B, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AK7371),      value = 0x0F, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_BU64297GWZ),  value = 0x10, flags = RESET_REQUIRED;
      endoneof;

      // I2C devices
      numeric varid     = SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK2_DEVICES_I2C),
        help        = STRING_TOKEN(STR_MIPICAM_DEVICES_I2C),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 12,
        step     = 1,
        default  = 6,
      endnumeric;

      suppressif ideqval SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0;
        // I2C channel
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C Device 0
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE0);

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS0),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x10,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE0),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif ;

      // I2C Device 1
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE1);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS1),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x0E,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE1),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 2
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE2);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS2),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x50,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE2),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 3
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE3);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS3),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x51,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE3),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 4
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3 4;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE4);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS4),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x52,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE4),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 5
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE5);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS5),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x53,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE5),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 6
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE6);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS6),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x54,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE6),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 7
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE7);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS7),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x55,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE7),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 8
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE8);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS8),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x56,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE8),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 9
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE9);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS9),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x57,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE9),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 10
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE10);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS10),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x58,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE10),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 11
      suppressif ideqvallist SETUP_DATA.MipiCam_Link2_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE11);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link2_I2cAddress[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_ADDRESS11),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x59,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link2_I2cDeviceType[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK2_I2C_DEVICE_TYPE11),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;
    endform;

    // *********************************************************
    form formid = 144,
      title    = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_LINK3);

      oneof varid   = SETUP_DATA.MipiCam_Link3_SensorModel,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_SENSOR_MODEL),
        help        = STRING_TOKEN(STR_MIPICAM_SENSOR_MODEL),
        option text = STRING_TOKEN(STR_MIPICAM_IMX135), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5693), value = 1, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX179), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8858), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9728), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX188), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX208), value = 7, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5670), value = 8, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8865), value = 9, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_HM2051), value = 10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2742), value = 11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9234), value = 12, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8856), value = 13, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV16860), value = 14, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX362), value = 15, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX488), value = 16, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_USER), value = 255, flags = RESET_REQUIRED;
      endoneof;

      // User defined _HID for Link3
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link3_SensorModel == 255;
         string varid = SETUP_DATA.MipiCam_Link3_UserHid,
          prompt   = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          help     = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          minsize  = 6,
          maxsize  = 8,
        endstring;
      endif;

      oneof varid     = SETUP_DATA.MipiCam_LanesClkDiv,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_LANES_CLK_DIV),
        help        = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_Link3_DriverData_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Control Logic
      oneof varid = SETUP_DATA.MipiCam_Link3_DriverData_ControlLogic,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_GPIO_CONTROL),
        help     = STRING_TOKEN(STR_MIPICAM_GPIO_CONTROL),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC4), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC5), value = 3, flags = RESET_REQUIRED;
        endif
      endoneof;

      // Physical location
      oneof varid     = SETUP_DATA.MipiCam_Link3_CameraPhysicalLocation,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_LOCATION),
        help        = STRING_TOKEN(STR_MIPICAM_LOCATION),
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x61, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x69, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // Flash support
      oneof varid     = SETUP_DATA.MipiCam_Link3_DriverData_FlashSupport,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_FLASH_SUPPORT),
        help        = STRING_TOKEN(STR_MIPICAM_FLASH_SUPPORT),
        option text = STRING_TOKEN(STR_MIPICAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
      endoneof;

      // Privacy LED
      oneof varid   = SETUP_DATA.MipiCam_Link3_DriverData_PrivacyLed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_PRIVACY_LED),
        help        = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED),
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // Rotation
      oneof varid     = SETUP_DATA.MipiCam_Link3_DriverData_Degree,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_DEGREE),
        help        = STRING_TOKEN(STR_MIPICAM_DEGREE),
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
      endoneof;

      // PMIC Position
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link3_DriverData_CrdVersion == 0x50;
        oneof varid   = SETUP_DATA.MipiCam_Link3_DriverData_PmicPosition,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_PMIC_POSITION),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION),
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Voltage Rail
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link3_DriverData_PmicPosition == 1;
        oneof varid   = SETUP_DATA.MipiCam_Link3_DriverData_VoltageRail,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_VOLTAGE_RAIL),
          help        = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL),
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // PPR Value
      numeric varid = SETUP_DATA.MipiCam_Link3_DriverData_PprValue,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_PPR_VALUE),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_VALUE_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 255,
        step     = 1,
        default  = 16,
      endnumeric;

      // PPR Unit
      numeric varid = SETUP_DATA.MipiCam_Link3_DriverData_PprUnit,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_PPR_UNIT),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_UNIT_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 15,
        step     = 1,
        default  = 10,
      endnumeric;

      // Camera Module Name
      string varid    = SETUP_DATA.MipiCam_Link3_ModuleName,
        prompt   = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        help     = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        minsize  = 1,
        maxsize  = 15,
      endstring;

      // Lane Used
      oneof varid     = SETUP_DATA.MipiCam_Link3_DriverData_LaneUsed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_SDD_LANE_USED),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_LANE_USED),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X4), value = 4, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // MCLK
      numeric varid     = SETUP_DATA.MipiCam_Link3_DriverData_Mclk,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_MCLK),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_MCLK),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 6000000,
        maximum  = 27000000,
        step     = 100000,
        default  = 19200000,
      endnumeric;

      // EEPROM Type
      oneof varid     = SETUP_DATA.MipiCam_Link3_DriverData_EepromType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_SDD_EEPROM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_M24C64), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_DW9806B), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C16), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C64), value = 0x11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA16), value = 0x12, flags = RESET_REQUIRED;
      endoneof;

      // VCM Type
      oneof varid     = SETUP_DATA.MipiCam_Link3_DriverData_VcmType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_SDD_VCM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_VCM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_NONE),        value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5823),      value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9714),      value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5816),      value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9719),      value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9718),      value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9806B),     value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_WV517S),      value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898122XA),  value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898212AXB), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED1),   value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED2),   value = 0x0B, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AK7371),      value = 0x0F, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_BU64297GWZ),  value = 0x10, flags = RESET_REQUIRED;
      endoneof;

      // I2C devices
      numeric varid     = SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_DEVICES_I2C),
        help        = STRING_TOKEN(STR_MIPICAM_DEVICES_I2C),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 12,
        step     = 1,
        default  = 6,
      endnumeric;

      suppressif ideqval SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0;
        // I2C channel
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C Device 0
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE0);

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS0),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x10,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE0),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif ;

      // I2C Device 1
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE1);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS1),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x0C,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE1),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 2
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE2);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS2),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x50,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE2),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 3
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE3);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS3),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x51,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE3),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 4
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3 4;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE4);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS4),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x52,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE4),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 5
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE5);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS5),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x53,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE5),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 6
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE6);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS6),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x54,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE6),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 7
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE7);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS7),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x55,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE7),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 8
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE8);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS8),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x56,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE8),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 9
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE9);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS9),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x57,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE9),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 10
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE10);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS10),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x58,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE10),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 11
      suppressif ideqvallist SETUP_DATA.MipiCam_Link3_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE11);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link3_I2cAddress[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_ADDRESS11),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x59,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link3_I2cDeviceType[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK3_I2C_DEVICE_TYPE11),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;
    endform;

    // *********************************************************
    form formid = 145,
      title    = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_LINK4);

      oneof varid   = SETUP_DATA.MipiCam_Link4_SensorModel,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_SENSOR_MODEL),
        help        = STRING_TOKEN(STR_MIPICAM_SENSOR_MODEL),
        option text = STRING_TOKEN(STR_MIPICAM_IMX135), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5693), value = 1, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX179), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8858), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9728), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX188), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX208), value = 7, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5670), value = 8, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8865), value = 9, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_HM2051), value = 10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2742), value = 11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9234), value = 12, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8856), value = 13, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV16860), value = 14, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX362), value = 15, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX488), value = 16, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_USER), value = 255, flags = RESET_REQUIRED;
      endoneof;

      // User defined _HID for Link4
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link4_SensorModel == 255;
         string varid = SETUP_DATA.MipiCam_Link4_UserHid,
          prompt   = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          help     = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          minsize  = 6,
          maxsize  = 8,
        endstring;
      endif;

      oneof varid     = SETUP_DATA.MipiCam_LanesClkDiv,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_LANES_CLK_DIV),
        help        = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_Link4_DriverData_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Control Logic
      oneof varid = SETUP_DATA.MipiCam_Link4_DriverData_ControlLogic,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_GPIO_CONTROL),
        help     = STRING_TOKEN(STR_MIPICAM_GPIO_CONTROL),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC4), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC5), value = 3, flags = RESET_REQUIRED;
        endif
      endoneof;

      // Physical location
      oneof varid     = SETUP_DATA.MipiCam_Link4_CameraPhysicalLocation,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_LOCATION),
        help        = STRING_TOKEN(STR_MIPICAM_LOCATION),
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x61, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x69, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // Flash support
      oneof varid     = SETUP_DATA.MipiCam_Link4_DriverData_FlashSupport,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_FLASH_SUPPORT),
        help        = STRING_TOKEN(STR_MIPICAM_FLASH_SUPPORT),
        option text = STRING_TOKEN(STR_MIPICAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
      endoneof;

      // Privacy LED
      oneof varid   = SETUP_DATA.MipiCam_Link4_DriverData_PrivacyLed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_PRIVACY_LED),
        help        = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED),
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // Rotation
      oneof varid     = SETUP_DATA.MipiCam_Link4_DriverData_Degree,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_DEGREE),
        help        = STRING_TOKEN(STR_MIPICAM_DEGREE),
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
      endoneof;

      // PMIC Position
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link4_DriverData_CrdVersion == 0x50;
        oneof varid   = SETUP_DATA.MipiCam_Link4_DriverData_PmicPosition,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_PMIC_POSITION),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION),
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Voltage Rail
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link4_DriverData_PmicPosition == 1;
        oneof varid   = SETUP_DATA.MipiCam_Link4_DriverData_VoltageRail,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_VOLTAGE_RAIL),
          help        = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL),
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // PPR Value
      numeric varid = SETUP_DATA.MipiCam_Link4_DriverData_PprValue,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_PPR_VALUE),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_VALUE_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 255,
        step     = 1,
        default  = 16,
      endnumeric;

      // PPR Unit
      numeric varid = SETUP_DATA.MipiCam_Link4_DriverData_PprUnit,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_PPR_UNIT),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_UNIT_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 15,
        step     = 1,
        default  = 10,
      endnumeric;

      // Camera Module Name
      string varid    = SETUP_DATA.MipiCam_Link4_ModuleName,
        prompt   = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        help     = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        minsize  = 1,
        maxsize  = 15,
      endstring;

      // Lane Used
      oneof varid     = SETUP_DATA.MipiCam_Link4_DriverData_LaneUsed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_SDD_LANE_USED),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_LANE_USED),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X4), value = 4, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // MCLK
      numeric varid     = SETUP_DATA.MipiCam_Link4_DriverData_Mclk,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_MCLK),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_MCLK),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 6000000,
        maximum  = 27000000,
        step     = 100000,
        default  = 19200000,
      endnumeric;

      // EEPROM Type
      oneof varid     = SETUP_DATA.MipiCam_Link4_DriverData_EepromType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_SDD_EEPROM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_M24C64), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_DW9806B), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C16), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C64), value = 0x11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA16), value = 0x12, flags = RESET_REQUIRED;
      endoneof;

      // VCM Type
      oneof varid     = SETUP_DATA.MipiCam_Link4_DriverData_VcmType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_SDD_VCM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_VCM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_NONE),        value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5823),      value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9714),      value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5816),      value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9719),      value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9718),      value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9806B),     value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_WV517S),      value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898122XA),  value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898212AXB), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED1),   value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED2),   value = 0x0B, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AK7371),      value = 0x0F, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_BU64297GWZ),  value = 0x10, flags = RESET_REQUIRED;
      endoneof;

      // I2C devices
      numeric varid     = SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK4_DEVICES_I2C),
        help        = STRING_TOKEN(STR_MIPICAM_DEVICES_I2C),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 12,
        step     = 1,
        default  = 6,
      endnumeric;

      suppressif ideqval SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0;
        // I2C channel
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C Device 0
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE0);

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS0),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x10,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE0),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif ;

      // I2C Device 1
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE1);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS1),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x0C,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE1),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 2
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE2);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS2),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x50,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE2),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 3
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE3);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS3),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x51,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE3),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 4
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3 4;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE4);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS4),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x52,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE4),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 5
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3 4 5;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE5);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS5),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x53,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE5),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 6
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3 4 5 6;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE6);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS6),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x54,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE6),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 7
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE7);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS7),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x55,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE7),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 8
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE8);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS8),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x56,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE8),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 9
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE9);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS9),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x57,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE9),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 10
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE10);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS10),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x58,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE10),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 11
      suppressif ideqvallist SETUP_DATA.MipiCam_Link4_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE11);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link4_I2cAddress[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_ADDRESS11),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x59,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link4_I2cDeviceType[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK4_I2C_DEVICE_TYPE11),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;
    endform;

    // *********************************************************
    form formid = 146,
      title    = STRING_TOKEN(STR_MIPICAM_LINK_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_LINK5);

      oneof varid   = SETUP_DATA.MipiCam_Link5_SensorModel,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_SENSOR_MODEL),
        help        = STRING_TOKEN(STR_MIPICAM_SENSOR_MODEL),
        option text = STRING_TOKEN(STR_MIPICAM_IMX135), value = 0, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5693), value = 1, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX179), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8858), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2740_IVCAM), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9728), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX188), value = 6, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX208), value = 7, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV5670), value = 8, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8865), value = 9, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_HM2051), value = 10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV2742), value = 11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV9234), value = 12, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV8856), value = 13, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_OV16860), value = 14, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX362), value = 15, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_IMX488), value = 16, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_USER), value = 255, flags = RESET_REQUIRED;
      endoneof;

      // User defined _HID for Link5
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link5_SensorModel == 255;
         string varid = SETUP_DATA.MipiCam_Link5_UserHid,
          prompt   = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          help     = STRING_TOKEN(STR_MIPICAM_CUSTOM_HID),
          minsize  = 6,
          maxsize  = 8,
        endstring;
      endif;

      oneof varid     = SETUP_DATA.MipiCam_LanesClkDiv,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_LANES_CLK_DIV),
        help        = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4422), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4431), value = 0x02, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_4440), value = 0x03, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8022), value = 0x04, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8031), value = 0x06, flags =  RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_CLK_DIV_8040), value = 0x07, flags =  RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_Link5_DriverData_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Control Logic
      oneof varid = SETUP_DATA.MipiCam_Link5_DriverData_ControlLogic,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_GPIO_CONTROL),
        help     = STRING_TOKEN(STR_MIPICAM_GPIO_CONTROL),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_NONE), value = 0xFF, flags = DEFAULT | RESET_REQUIRED;
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0), value = 0, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1), value = 1, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC2), value = 2, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC3), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC4), value = 3, flags = RESET_REQUIRED;
        endif
        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5 == 0;
          option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC5), value = 3, flags = RESET_REQUIRED;
        endif
      endoneof;

      // Physical location
      oneof varid     = SETUP_DATA.MipiCam_Link5_CameraPhysicalLocation,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_LOCATION),
        help        = STRING_TOKEN(STR_MIPICAM_LOCATION),
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x61, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x69, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // Flash support
      oneof varid     = SETUP_DATA.MipiCam_Link5_DriverData_FlashSupport,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_FLASH_SUPPORT),
        help        = STRING_TOKEN(STR_MIPICAM_FLASH_SUPPORT),
        option text = STRING_TOKEN(STR_MIPICAM_FLASH_DRIVER_DEFAULT), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_DISABLED), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_ENABLED), value = 3, flags = RESET_REQUIRED;
      endoneof;

      // Privacy LED
      oneof varid   = SETUP_DATA.MipiCam_Link5_DriverData_PrivacyLed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_PRIVACY_LED),
        help        = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED),
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_DRIVER_DEFAULT), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDA_16MA), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_2MA), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_4MA), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_8MA), value = 4, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PRIVACY_LED_ILEDB_16MA), value = 5, flags = RESET_REQUIRED;
      endoneof;

      // Rotation
      oneof varid     = SETUP_DATA.MipiCam_Link5_DriverData_Degree,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_DEGREE),
        help        = STRING_TOKEN(STR_MIPICAM_DEGREE),
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_0), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_45), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_90), value = 2, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_135), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_180), value = 4, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_225), value = 5, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_DEGREE_270), value = 6, flags = RESET_REQUIRED;
        //option text = STRING_TOKEN(STR_MIPICAM_DEGREE_315), value = 7, flags = RESET_REQUIRED;
      endoneof;

      // PMIC Position
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link5_DriverData_CrdVersion == 0x50;
        oneof varid   = SETUP_DATA.MipiCam_Link5_DriverData_PmicPosition,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK3_PMIC_POSITION),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION),
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_1), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_PMIC_POSITION_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // Voltage Rail
      suppressif NOT ideqval SETUP_DATA.MipiCam_Link5_DriverData_PmicPosition == 1;
        oneof varid   = SETUP_DATA.MipiCam_Link5_DriverData_VoltageRail,
          prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_VOLTAGE_RAIL),
          help        = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL),
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_3), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_VOLTAGE_RAIL_2), value = 1, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // PPR Value
      numeric varid = SETUP_DATA.MipiCam_Link5_DriverData_PprValue,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_PPR_VALUE),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_VALUE_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 255,
        step     = 1,
        default  = 16,
      endnumeric;

      // PPR Unit
      numeric varid = SETUP_DATA.MipiCam_Link5_DriverData_PprUnit,
        prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_PPR_UNIT),
        help     = STRING_TOKEN(STR_MIPICAM_PPR_UNIT_HELP),
        flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
        minimum  = 0,
        maximum  = 15,
        step     = 1,
        default  = 10,
      endnumeric;

      // Camera Module Name
      string varid    = SETUP_DATA.MipiCam_Link5_ModuleName,
        prompt   = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        help     = STRING_TOKEN(STR_MIPICAM_MODULE_NAME),
        minsize  = 1,
        maxsize  = 15,
      endstring;

      // Lane Used
      oneof varid     = SETUP_DATA.MipiCam_Link5_DriverData_LaneUsed,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_SDD_LANE_USED),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_LANE_USED),
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_LANES_X4), value = 4, flags = DEFAULT | RESET_REQUIRED;
      endoneof;

      // MCLK
      numeric varid     = SETUP_DATA.MipiCam_Link5_DriverData_Mclk,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK0_SDD_MCLK),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_MCLK),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 6000000,
        maximum  = 27000000,
        step     = 100000,
        default  = 19200000,
      endnumeric;

      // EEPROM Type
      oneof varid     = SETUP_DATA.MipiCam_Link5_DriverData_EepromType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_SDD_EEPROM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_NONE), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ROM_OTP), value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_64), value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_16K_16), value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_OTP_ACPI_ACPI), value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_ACPI), value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_BRCA016GWZ), value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA32), value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C08), value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_M24C64), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_DW9806B), value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C16), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_CAT24C64), value = 0x11, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_EEPROM_24AA16), value = 0x12, flags = RESET_REQUIRED;
      endoneof;

      // VCM Type
      oneof varid     = SETUP_DATA.MipiCam_Link5_DriverData_VcmType,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_SDD_VCM_TYPE),
        help        = STRING_TOKEN(STR_MIPICAM_SDD_VCM_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_NONE),        value = 0x00, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5823),      value = 0x01, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9714),      value = 0x02, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AD5816),      value = 0x03, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9719),      value = 0x04, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9718),      value = 0x05, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_DW9806B),     value = 0x06, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_WV517S),      value = 0x07, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898122XA),  value = 0x08, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_LC898212AXB), value = 0x09, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED1),   value = 0x0A, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_RESERVED2),   value = 0x0B, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_AK7371),      value = 0x0F, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_VCM_BU64297GWZ),  value = 0x10, flags = RESET_REQUIRED;
      endoneof;

      // I2C devices
      numeric varid     = SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled,
        prompt      = STRING_TOKEN(STR_MIPICAM_LINK5_DEVICES_I2C),
        help        = STRING_TOKEN(STR_MIPICAM_DEVICES_I2C),
        flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
        minimum  = 0,
        maximum  = 12,
        step     = 1,
        default  = 6,
      endnumeric;

      suppressif ideqval SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0;
        // I2C channel
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C Device 0
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE0);

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS0),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x10,
        endnumeric;

        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[0],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE0),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif ;

      // I2C Device 1
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE1);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS1),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x0C,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[1],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE1),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 2
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE2);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS2),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x50,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[2],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE2),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 3
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE3);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS3),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x51,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[3],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE3),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 4
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3 4;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE4);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS4),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x52,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[4],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE4),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 5
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3 4 5;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE5);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS5),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x53,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[5],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE5),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 6
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3 4 5 6;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE6);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS6),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x54,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[6],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE6),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 7
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3 4 5 6 7;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE7);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS7),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x55,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[7],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE7),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 8
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE8);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS8),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x56,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[8],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE8),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 9
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE9);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS9),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x57,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[9],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE9),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 10
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE10);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS10),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x58,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[10],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE10),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = RESET_REQUIRED;
        endoneof;
      endif;

      // I2C Device 11
      suppressif ideqvallist SETUP_DATA.MipiCam_Link5_I2cDevicesEnabled == 0 1 2 3 4 5 6 7 8 9 10 11;
        subtitle text = STRING_TOKEN(STR_MIPICAM_DEVICE11);
        // I2C address
        numeric varid = SETUP_DATA.MipiCam_Link5_I2cAddress[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_ADDRESS11),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x59,
        endnumeric;
        // I2C device type
        oneof varid = SETUP_DATA.MipiCam_Link5_I2cDeviceType[11],
          prompt   = STRING_TOKEN(STR_MIPICAM_LINK5_I2C_DEVICE_TYPE11),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE),
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_SENSOR), value = 0x00, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_VCM), value = 0x01, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM), value = 0x02, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT1), value = 0x03, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT2), value = 0x04, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT3), value = 0x05, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT4), value = 0x06, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT5), value = 0x07, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT6), value = 0x08, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_EEPROM_EXT7), value = 0x09, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_IO_EXPANDER), value = 0x0A, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_I2C_DEVICE_TYPE_FLASH), value = 0x0C, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;
    endform;

    // *********************************************************
    form formid = 147,
      title    = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);

      // Type of logic
      oneof varid = SETUP_DATA.MipiCam_ControlLogic0_Type,
        prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC0_TYPE),
        help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_ControlLogic0_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_CL0_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Input Clock
      oneof varid = SETUP_DATA.MipiCam_ControlLogic0_InputClock,
        prompt   = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        help     = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_0), value = 0x10, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_1), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_2), value = 0x30, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_3), value = 0x40, flags = RESET_REQUIRED;
      endoneof;

      // Pch Clock Source
      oneof varid = SETUP_DATA.MipiCam_ControlLogic0_PchClockSource,
        prompt   = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE),
        help     = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_HELP),
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_0), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_4), value = 4, flags = RESET_REQUIRED;
      endoneof;

      suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic0_CrdVersion == 0x30 0x50;
        // PMIC Flash Panel
        oneof varid   = SETUP_DATA.MipiCam_ControlLogic0_Pld,
          prompt      = STRING_TOKEN(STR_MIPICAM_CL0_PMIC_FLASH_PANEL),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x21, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x29, flags = RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0_Type == 1;
        // show below options when PMIC is used
        // I2C Channel
        oneof varid = SETUP_DATA.MipiCam_ControlLogic0_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_CL0_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_ControlLogic0_I2cAddress,
          prompt   = STRING_TOKEN(STR_MIPICAM_CL0_I2C_ADDRESS_MAIN),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x4D, defaultstore = MyStandardDefault,
        endnumeric;

        suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic0_Type == 2 3;
          // WLED1 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic0_Wled1Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL0_WLED1_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED1 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_Wled1FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL0_WLED1_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED1 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_Wled1TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL0_WLED1_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic0_Wled2Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL0_WLED2_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED2 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_Wled2FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL0_WLED2_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_Wled2TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL0_WLED2_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // SubPlatformId 0~0xF
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_SubPlatformId,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL0_SUBPLATFORM_ID),
            help        = STRING_TOKEN(STR_MIPICAM_CL0_SUBPLATFORM_ID),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0xF,
            step        = 1,
            default     = 0,
          endnumeric;
        endif;
      endif;

      suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic0_Type == 253 254;
        // show below options when DISCRETE is used
        // Number of GPIO pins enabled
        numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioPinsEnabled,
          prompt      = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_PIN_COUNT),
          help        = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 4,
          step     = 1,
          default  = 2,
        endnumeric;

        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic0_GpioPinsEnabled == 0;
        // GPIO Pin 0
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_0);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioGroupPadNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_GROUP_PAD_NUMBER0),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 22,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic0_GpioGroupNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_GROUP_NUMBER0),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic0_GpioFunction[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_FUNCTION0),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioActiveValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_ACTIVE_VALUE0),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioInitialValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_INITIAL_VALUE0),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;

        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic0_GpioPinsEnabled == 0 1;
          // GPIO Pin 1
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_1);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioGroupPadNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_GROUP_PAD_NUMBER1),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic0_GpioGroupNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_GROUP_NUMBER1),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic0_GpioFunction[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_FUNCTION1),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioActiveValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_ACTIVE_VALUE1),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioInitialValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_INITIAL_VALUE1),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic0_GpioPinsEnabled == 0 1 2;
          // GPIO Pin 2
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_2);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioGroupPadNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_GROUP_PAD_NUMBER2),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic0_GpioGroupNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_GROUP_NUMBER2),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic0_GpioFunction[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_FUNCTION2),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioActiveValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_ACTIVE_VALUE2),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioInitialValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_INITIAL_VALUE2),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;


        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic0_GpioPinsEnabled == 0 1 2 3;
          // GPIO Pin 3
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_3);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioGroupPadNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_GROUP_PAD_NUMBER3),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic0_GpioGroupNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_GROUP_NUMBER3),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic0_GpioFunction[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_FUNCTION3),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioActiveValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_ACTIVE_VALUE3),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic0_GpioInitialValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL0_GPIO_INITIAL_VALUE3),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;
      endif ;
    endform;

    // *********************************************************
    form formid = 148,
      title    = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);

      // Type of logic
      oneof varid = SETUP_DATA.MipiCam_ControlLogic1_Type,
        prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC1_TYPE),
        help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_ControlLogic1_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_CL1_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Input Clock
      oneof varid = SETUP_DATA.MipiCam_ControlLogic1_InputClock,
        prompt   = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        help     = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_0), value = 0x10, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_1), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_2), value = 0x30, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_3), value = 0x40, flags = RESET_REQUIRED;
      endoneof;

      // Pch Clock Source
      oneof varid = SETUP_DATA.MipiCam_ControlLogic1_PchClockSource,
        prompt   = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE),
        help     = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_HELP),
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_0), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_4), value = 4, flags = RESET_REQUIRED;
      endoneof;

      suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic1_CrdVersion == 0x30 0x50;
        // PMIC Flash Panel
        oneof varid   = SETUP_DATA.MipiCam_ControlLogic1_Pld,
          prompt      = STRING_TOKEN(STR_MIPICAM_CL1_PMIC_FLASH_PANEL),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x21, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x29, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1_Type == 1;
        // show below options when PMIC is used
        // I2C Channel
        oneof varid = SETUP_DATA.MipiCam_ControlLogic1_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_CL1_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_ControlLogic1_I2cAddress,
          prompt   = STRING_TOKEN(STR_MIPICAM_CL1_I2C_ADDRESS_MAIN),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x49,
        endnumeric;

        suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic1_Type == 2 3;
          // WLED1 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic1_Wled1Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL1_WLED1_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED1 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_Wled1FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL1_WLED1_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED1 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_Wled1TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL1_WLED1_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic1_Wled2Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL1_WLED2_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED2 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_Wled2FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL1_WLED2_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_Wled2TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL1_WLED2_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // SubPlatformId 0~0xF
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_SubPlatformId,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL1_SUBPLATFORM_ID),
            help        = STRING_TOKEN(STR_MIPICAM_CL1_SUBPLATFORM_ID),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0xF,
            step        = 1,
            default     = 0,
          endnumeric;
        endif;
    endif;

      suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic1_Type == 253 254;
        // show below options when DISCRETE is used
        // Number of GPIO pins enabled
        numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioPinsEnabled,
          prompt      = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_PIN_COUNT),
          help        = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 4,
          step     = 1,
          default  = 2,
        endnumeric;

        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic1_GpioPinsEnabled == 0;
        // I2C Device 0
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_0);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioGroupPadNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_GROUP_PAD_NUMBER0),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 22,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic1_GpioGroupNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_GROUP_NUMBER0),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic1_GpioFunction[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_FUNCTION0),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioActiveValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_ACTIVE_VALUE0),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioInitialValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_INITIAL_VALUE0),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;

        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic1_GpioPinsEnabled == 0 1;
          // GPIO Pin 1
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_1);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioGroupPadNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_GROUP_PAD_NUMBER1),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic1_GpioGroupNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_GROUP_NUMBER1),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic1_GpioFunction[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_FUNCTION1),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioActiveValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_ACTIVE_VALUE1),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioInitialValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_INITIAL_VALUE1),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic1_GpioPinsEnabled == 0 1 2;
          // GPIO Pin 2
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_2);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioGroupPadNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_GROUP_PAD_NUMBER2),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic1_GpioGroupNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_GROUP_NUMBER2),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic1_GpioFunction[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_FUNCTION2),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioActiveValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_ACTIVE_VALUE2),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioInitialValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_INITIAL_VALUE2),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;


        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic1_GpioPinsEnabled == 0 1 2 3;
          // GPIO Pin 3
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_3);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioGroupPadNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_GROUP_PAD_NUMBER3),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic1_GpioGroupNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_GROUP_NUMBER3),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic1_GpioFunction[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_FUNCTION3),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioActiveValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_ACTIVE_VALUE3),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic1_GpioInitialValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_CL1_GPIO_INITIAL_VALUE3),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;
      endif ;
     endform;

    // *********************************************************
    form formid = 149,
      title    = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);

      // Type of logic
      oneof varid = SETUP_DATA.MipiCam_ControlLogic2_Type,
        prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_ControlLogic2_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Input Clock
      oneof varid = SETUP_DATA.MipiCam_ControlLogic2_InputClock,
        prompt   = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        help     = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_0), value = 0x10, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_1), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_2), value = 0x30, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_3), value = 0x40, flags = RESET_REQUIRED;
      endoneof;

      // Pch Clock Source
      oneof varid = SETUP_DATA.MipiCam_ControlLogic2_PchClockSource,
        prompt   = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE),
        help     = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_HELP),
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_0), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_4), value = 4, flags = RESET_REQUIRED;
      endoneof;

      suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic2_CrdVersion == 0x30 0x50;
        // PMIC Flash Panel
        oneof varid   = SETUP_DATA.MipiCam_ControlLogic2_Pld,
          prompt      = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x21, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x29, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2_Type == 1;
        // show below options when PMIC is used
        // I2C Channel
        oneof varid = SETUP_DATA.MipiCam_ControlLogic2_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_ControlLogic2_I2cAddress,
          prompt   = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x49,
        endnumeric;

        suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic2_Type == 2 3;
          // WLED1 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic2_Wled1Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL2_WLED1_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED1 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_Wled1FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL2_WLED1_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED1 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_Wled1TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL2_WLED1_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic2_Wled2Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL2_WLED2_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED2 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_Wled2FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL2_WLED2_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_Wled2TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL2_WLED2_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // SubPlatformId 0~0xF
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_SubPlatformId,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL2_SUBPLATFORM_ID),
            help        = STRING_TOKEN(STR_MIPICAM_CL2_SUBPLATFORM_ID),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0xF,
            step        = 1,
            default     = 0,
          endnumeric;
        endif;
      endif;

      suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic2_Type == 253 254;
        // show below options when DISCRETE is used
        // Number of GPIO pins enabled
        numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioPinsEnabled,
          prompt      = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          help        = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 4,
          step     = 1,
          default  = 2,
        endnumeric;

        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic2_GpioPinsEnabled == 0;
        // I2C Device 0
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_0);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioGroupPadNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 22,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic2_GpioGroupNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic2_GpioFunction[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioActiveValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioInitialValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;

        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic2_GpioPinsEnabled == 0 1;
          // GPIO Pin 1
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_1);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioGroupPadNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic2_GpioGroupNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic2_GpioFunction[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioActiveValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioInitialValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic2_GpioPinsEnabled == 0 1 2;
          // GPIO Pin 2
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_2);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioGroupPadNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic2_GpioGroupNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic2_GpioFunction[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioActiveValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioInitialValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;


        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic2_GpioPinsEnabled == 0 1 2 3;
          // GPIO Pin 3
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_3);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioGroupPadNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic2_GpioGroupNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic2_GpioFunction[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioActiveValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic2_GpioInitialValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;
      endif ;
     endform;

    // *********************************************************
    form formid = 150,
      title    = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);

      // Type of logic
      oneof varid = SETUP_DATA.MipiCam_ControlLogic3_Type,
        prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_ControlLogic3_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Input Clock
      oneof varid = SETUP_DATA.MipiCam_ControlLogic3_InputClock,
        prompt   = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        help     = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_0), value = 0x10, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_1), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_2), value = 0x30, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_3), value = 0x40, flags = RESET_REQUIRED;
      endoneof;

      // Pch Clock Source
      oneof varid = SETUP_DATA.MipiCam_ControlLogic3_PchClockSource,
        prompt   = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE),
        help     = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_HELP),
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_0), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_4), value = 4, flags = RESET_REQUIRED;
      endoneof;

      suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic3_CrdVersion == 0x30 0x50;
        // PMIC Flash Panel
        oneof varid   = SETUP_DATA.MipiCam_ControlLogic3_Pld,
          prompt      = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x21, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x29, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3_Type == 1;
        // show below options when PMIC is used
        // I2C Channel
        oneof varid = SETUP_DATA.MipiCam_ControlLogic3_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_ControlLogic3_I2cAddress,
          prompt   = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x49,
        endnumeric;

        suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic3_Type == 2 3;
          // WLED1 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic3_Wled1Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL3_WLED1_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED1 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_Wled1FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL3_WLED1_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED1 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_Wled1TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL3_WLED1_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic3_Wled2Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL3_WLED2_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED2 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_Wled2FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL3_WLED2_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_Wled2TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL3_WLED2_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // SubPlatformId 0~0xF
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_SubPlatformId,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL3_SUBPLATFORM_ID),
            help        = STRING_TOKEN(STR_MIPICAM_CL3_SUBPLATFORM_ID),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0xF,
            step        = 1,
            default     = 0,
          endnumeric;
        endif;

      endif;

      suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic3_Type == 253 254;
        // show below options when DISCRETE is used
        // Number of GPIO pins enabled
        numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioPinsEnabled,
          prompt      = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          help        = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 4,
          step     = 1,
          default  = 2,
        endnumeric;

        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic3_GpioPinsEnabled == 0;
        // I2C Device 0
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_0);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioGroupPadNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 22,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic3_GpioGroupNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic3_GpioFunction[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioActiveValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioInitialValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;

        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic3_GpioPinsEnabled == 0 1;
          // GPIO Pin 1
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_1);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioGroupPadNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic3_GpioGroupNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic3_GpioFunction[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioActiveValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioInitialValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic3_GpioPinsEnabled == 0 1 2;
          // GPIO Pin 2
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_2);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioGroupPadNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic3_GpioGroupNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic3_GpioFunction[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioActiveValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioInitialValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;


        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic3_GpioPinsEnabled == 0 1 2 3;
          // GPIO Pin 3
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_3);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioGroupPadNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic3_GpioGroupNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic3_GpioFunction[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioActiveValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic3_GpioInitialValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;
      endif ;
     endform;

    // *********************************************************
    form formid = 151,
      title    = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);

      // Type of logic
      oneof varid = SETUP_DATA.MipiCam_ControlLogic4_Type,
        prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_ControlLogic4_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Input Clock
      oneof varid = SETUP_DATA.MipiCam_ControlLogic4_InputClock,
        prompt   = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        help     = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_0), value = 0x10, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_1), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_2), value = 0x30, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_3), value = 0x40, flags = RESET_REQUIRED;
      endoneof;

      // Pch Clock Source
      oneof varid = SETUP_DATA.MipiCam_ControlLogic4_PchClockSource,
        prompt   = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE),
        help     = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_HELP),
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_0), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_4), value = 4, flags = RESET_REQUIRED;
      endoneof;

      suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic4_CrdVersion == 0x30 0x50;
        // PMIC Flash Panel
        oneof varid   = SETUP_DATA.MipiCam_ControlLogic4_Pld,
          prompt      = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x21, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x29, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4_Type == 1;
        // show below options when PMIC is used
        // I2C Channel
        oneof varid = SETUP_DATA.MipiCam_ControlLogic4_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_ControlLogic4_I2cAddress,
          prompt   = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x49,
        endnumeric;

        suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic4_Type == 2 3;
          // WLED1 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic4_Wled1Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL4_WLED1_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED1 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_Wled1FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL4_WLED1_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED1 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_Wled1TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL4_WLED1_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic4_Wled2Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL4_WLED2_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED2 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_Wled2FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL4_WLED2_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_Wled2TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL4_WLED2_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // SubPlatformId 0~0xF
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_SubPlatformId,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL4_SUBPLATFORM_ID),
            help        = STRING_TOKEN(STR_MIPICAM_CL4_SUBPLATFORM_ID),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0xF,
            step        = 1,
            default     = 0,
          endnumeric;
        endif;

      endif;

      suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic4_Type == 253 254;
        // show below options when DISCRETE is used
        // Number of GPIO pins enabled
        numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioPinsEnabled,
          prompt      = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          help        = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 4,
          step     = 1,
          default  = 2,
        endnumeric;

        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic4_GpioPinsEnabled == 0;
        // I2C Device 0
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_0);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioGroupPadNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 22,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic4_GpioGroupNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic4_GpioFunction[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioActiveValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioInitialValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;

        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic4_GpioPinsEnabled == 0 1;
          // GPIO Pin 1
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_1);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioGroupPadNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic4_GpioGroupNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic4_GpioFunction[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioActiveValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioInitialValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic4_GpioPinsEnabled == 0 1 2;
          // GPIO Pin 2
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_2);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioGroupPadNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic4_GpioGroupNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic4_GpioFunction[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioActiveValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioInitialValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;


        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic4_GpioPinsEnabled == 0 1 2 3;
          // GPIO Pin 3
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_3);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioGroupPadNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic4_GpioGroupNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic4_GpioFunction[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioActiveValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic4_GpioInitialValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;
      endif ;
     endform;

    // *********************************************************
    form formid = 152,
      title    = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);
      subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_OPTIONS);

      // Type of logic
      oneof varid = SETUP_DATA.MipiCam_ControlLogic5_Type,
        prompt   = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        help     = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_TYPE),
        option text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_DISCRETE), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_TPS68470), value = 2, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_UP6641), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER0), value = 253, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PMIC_USER1), value = 254, flags = RESET_REQUIRED;
      endoneof;

      // Version of CRD
      oneof varid = SETUP_DATA.MipiCam_ControlLogic5_CrdVersion,
        prompt   = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        help     = STRING_TOKEN(STR_MIPICAM_SDD_CRD),
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_PTC), value = 0x10, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_D), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G), value = 0x30, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_KILSHON_PPV), value = 0x40, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_SDD_CRD_G2), value = 0x50, flags = RESET_REQUIRED;
      endoneof;

      // Input Clock
      oneof varid = SETUP_DATA.MipiCam_ControlLogic5_InputClock,
        prompt   = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        help     = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK),
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_0), value = 0x10, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_1), value = 0x20, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_2), value = 0x30, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_INPUT_CLOCK_3), value = 0x40, flags = RESET_REQUIRED;
      endoneof;

      // Pch Clock Source
      oneof varid = SETUP_DATA.MipiCam_ControlLogic5_PchClockSource,
        prompt   = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE),
        help     = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_HELP),
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_0), value = 0, flags = DEFAULT | RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_1), value = 1, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_2), value = 2, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_3), value = 3, flags = RESET_REQUIRED;
        option text = STRING_TOKEN(STR_MIPICAM_PCH_CLOCK_SOURCE_4), value = 4, flags = RESET_REQUIRED;
      endoneof;

      suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic5_CrdVersion == 0x30 0x50;
        // PMIC Flash Panel
        oneof varid   = SETUP_DATA.MipiCam_ControlLogic5_Pld,
          prompt      = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          help        = STRING_TOKEN(STR_MIPICAM_PMIC_FLASH_PANEL),
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_FRONT), value = 0x21, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_MIPICAM_LOCATION_BACK), value = 0x29, flags = DEFAULT | RESET_REQUIRED;
        endoneof;
      endif;

      suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5_Type == 1;
        // show below options when PMIC is used
        // I2C Channel
        oneof varid = SETUP_DATA.MipiCam_ControlLogic5_I2cChannel,
          prompt   = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          help        = STRING_TOKEN(STR_MIPICAM_I2C_CHANNEL),
          option text = STRING_TOKEN(STR_CHANNEL_I2C0), value = 0, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C1), value = 1, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C2), value = 2, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C3), value = 3, flags = DEFAULT | RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C4), value = 4, flags = RESET_REQUIRED;
          option text = STRING_TOKEN(STR_CHANNEL_I2C5), value = 5, flags = RESET_REQUIRED;
        endoneof;

        // I2C address
        numeric varid = SETUP_DATA.MipiCam_ControlLogic5_I2cAddress,
          prompt   = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          help     = STRING_TOKEN(STR_MIPICAM_I2C_ADDRESS_MAIN),
          flags    = RESET_REQUIRED | DISPLAY_UINT_HEX,
          minimum  = 0,
          maximum  = 0x7F,
          step     = 1,
          default  = 0x49,
        endnumeric;

        suppressif NOT ideqvallist SETUP_DATA.MipiCam_ControlLogic5_Type == 2 3;
          // WLED1 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic5_Wled1Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL3_WLED1_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED1 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_Wled1FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL5_WLED1_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED1 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_Wled1TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL5_WLED1_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Type
          oneof varid   = SETUP_DATA.MipiCam_ControlLogic5_Wled2Type,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL5_WLED2_TYPE),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TYPE),
            option text = STRING_TOKEN(STR_DISABLED), value = 0, flags = DEFAULT | MANUFACTURING | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WHITE_LED), value = 1, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_WARM_LED), value = 2, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_IR_LED), value = 3, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_XEON_LED), value = 4, flags = RESET_REQUIRED;
          endoneof;

          // WLED2 Flash Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_Wled2FlashMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL5_WLED2_FLASH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_FLASH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x1F,
            step        = 1,
            default     = 0,
          endnumeric;

          // WLED2 Torch Max current
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_Wled2TorchMaxCurrent,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL5_WLED2_TORCH_MAX_CURRENT),
            help        = STRING_TOKEN(STR_MIPICAM_WLED_TORCH_MAX_CURRENT),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0x7,
            step        = 1,
            default     = 0,
          endnumeric;

          // SubPlatformId 0~0xF
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_SubPlatformId,
            prompt      = STRING_TOKEN(STR_MIPICAM_CL5_SUBPLATFORM_ID),
            help        = STRING_TOKEN(STR_MIPICAM_CL5_SUBPLATFORM_ID),
            flags       = RESET_REQUIRED | DISPLAY_UINT_HEX,
            minimum     = 0,
            maximum     = 0xF,
            step        = 1,
            default     = 0,
          endnumeric;
        endif;

      endif;

      suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic5_Type == 253 254;
        // show below options when DISCRETE is used
        // Number of GPIO pins enabled
        numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioPinsEnabled,
          prompt      = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          help        = STRING_TOKEN(STR_MIPICAM_GPIO_PIN_COUNT),
          flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
          minimum  = 0,
          maximum  = 4,
          step     = 1,
          default  = 2,
        endnumeric;

        suppressif ideqval SETUP_DATA.MipiCam_ControlLogic5_GpioPinsEnabled == 0;
        // I2C Device 0
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_0);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioGroupPadNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 22,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic5_GpioGroupNumber[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic5_GpioFunction[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioActiveValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioInitialValue[0],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;

        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic5_GpioPinsEnabled == 0 1;
          // GPIO Pin 1
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_1);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioGroupPadNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic5_GpioGroupNumber[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic5_GpioFunction[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioActiveValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioInitialValue[1],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;

        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic5_GpioPinsEnabled == 0 1 2;
          // GPIO Pin 2
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_2);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioGroupPadNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic5_GpioGroupNumber[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic5_GpioFunction[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioActiveValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioInitialValue[2],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;


        suppressif ideqvallist SETUP_DATA.MipiCam_ControlLogic5_GpioPinsEnabled == 0 1 2 3;
          // GPIO Pin 3
          subtitle text = STRING_TOKEN(STR_MIPICAM_CONTROL_LOGIC_GPIO_3);
          // GPIO Group Pad Number
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioGroupPadNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_PAD_NUMBER),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 23,
            step     = 1,
            default  = 11,
          endnumeric;

          // GPIO Group Number
          oneof varid = SETUP_DATA.MipiCam_ControlLogic5_GpioGroupNumber[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_NUMBER),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_A), value = 0x00, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_B), value = 0x01, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_C), value = 0x02, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_D), value = 0x03, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_E), value = 0x04, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_F), value = 0x05, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_G), value = 0x06, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_H), value = 0x07, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_GROUP_R), value = 0x08, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Function
          oneof varid = SETUP_DATA.MipiCam_ControlLogic5_GpioFunction[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            help      = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION),
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_RESET), value = 0x00, flags = DEFAULT | RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_POWER_EN), value = 0x0B, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_CLOCK_EN), value = 0x00C, flags = RESET_REQUIRED;
            option text = STRING_TOKEN(STR_MIPICAM_GPIO_FUNCTION_PLED_EN), value = 0x0D, flags = RESET_REQUIRED;
          endoneof;

          // GPIO Active Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioActiveValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_ACTIVE_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 1,
          endnumeric;

          // GPIO Initial Value
          numeric varid = SETUP_DATA.MipiCam_ControlLogic5_GpioInitialValue[3],
            prompt   = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            help     = STRING_TOKEN(STR_MIPICAM_GPIO_INITIAL_VALUE),
            flags    = RESET_REQUIRED | DISPLAY_UINT_DEC,
            minimum  = 0,
            maximum  = 1,
            step     = 1,
            default  = 0,
          endnumeric;
        endif;
      endif ;
     endform;
    // Display
    form formid = AUTO_ID(SA_DISPLAY_OPTIONS_FORM_ID),
    title     = STRING_TOKEN(STR_SA_DISPLAY_OPTIONS_FORM_TITLE);

    SUBTITLE(STRING_TOKEN(STR_SA_DISPLAY_OPTIONS_FORM_SUBTITLE))
    SEPARATOR

  endform;
